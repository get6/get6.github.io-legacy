<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/cf50bc513bb312fb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf50bc513bb312fb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf392dd387379326.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf392dd387379326.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-591bb7ec51acdc0d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3f357b7937ff6115.js" defer=""></script><script src="/_next/static/chunks/358-1fc680902af364db.js" defer=""></script><script src="/_next/static/chunks/675-717e3cc8fb67a947.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-f8930ebaf4ef3376.js" defer=""></script><script src="/_next/static/h_iCwTpJA7YjAPN2rGkKn/_buildManifest.js" defer=""></script><script src="/_next/static/h_iCwTpJA7YjAPN2rGkKn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="absolute w-full pt-3"><div class="container mx-auto flex flex-wrap"><a class="w-2/6 text-lg font-bold" href="/">🌎 Sunhwang&#x27;s blog</a><ul class="flex grow justify-end space-x-10"><li><a class="hover:underline hover:underline-offset-8 " href="/tags">Tags</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/about">About me</a></li></ul></div></nav><main><div class="container mx-auto pt-10"><article class="mb-32"><div class="mx-auto flex max-w-6xl justify-start align-middle"><h1 class="mt-20 mb-6 text-5xl font-bold leading-tight tracking-tighter md:text-left md:text-7xl md:leading-none lg:text-4xl">GoF(Gang of Four) Design Patterns 정리</h1></div><div class="mb-8 sm:mx-0 md:mb-16"><div class="sm:mx-0"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0"><img alt="Cover Image for GoF(Gang of Four) Design Patterns 정리" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="shadow-sm" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Cover Image for GoF(Gang of Four) Design Patterns 정리" src="" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="shadow-sm" loading="lazy"/></noscript></span></div></div><div class="mx-auto flex max-w-5xl justify-end"><div class="mb-4 text-sm text-gray-600 underline underline-offset-8"><time dateTime="2021-01-17">2021-01-17</time></div></div><div class="mx-auto max-w-6xl"><article class="markdown-styles_markdown__h_8de"><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Contents</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<p>정보처리기사책을 공부하다 보면 나오는 GoF 디자인 패턴이 나옵니다.</p>
<p>예제가 있으면 이해가 쉬울거 같아 정리를 해봅니다.</p>
<p>저는 Dart언어를 좋아해서 구글링을 해보니 이미 누군가가 정리해 놓은 글이 있어 인용합니다. <a href="https://scottt2.github.io/design-patterns-in-dart/">Dart로 구현한 Degisn Patterns</a></p>
<h1 id="생성creational-패턴">생성(Creational) 패턴</h1>
<ul>
<li>객체를 생성하는 데 사용되는 패턴이다.</li>
<li>클래스 정의와 객체 생성 방식을 구조화, 캡슐화한 방법을 제사한다.</li>
<li>객체를 생성하거나 수정되어도 프로그램 구조에 영향을 적게 받도록 한다.</li>
<li>캡슐화하여 부작용을 최소화한다.</li>
</ul>
<h2 id="종류">종류</h2>
<p>5개</p>
<h3 id="abstract-facotry">Abstract Facotry</h3>
<ul>
<li>추상 팩토리 패턴은 구체적인 클래스를 지정하지 않고 공통된 주제를 가진 개별 팩토리 그룹을 캡슐화하는 방법을 제공한다.</li>
</ul>
<pre><code class="language-dart">// '마실 수 있는' 추상형태를 가진 추상 클래스 정의
abstract class Drinkable {
  void pour(); // '붓다'라는 함수를 갖는다
}

// Beer 객체를 정의
// Drinkable 추상 클래스를 구현해 추상 팩토리에서 활용할 수 있는 객체로 만듦
class Beer implements Drinkable {
  // 함수를 구현
  void pour() {
    print("Pouring a delicious beer!");
  }
}

// Coffee 객체를 정의
// Beer와 마찬가지로 Drinkable에는 두 종류의 구현 객체가 존재
class Coffee implements Drinkable {
  void pour() {
    print("Pouring a refreshing coffee!");
  }
}

// 추상 팩토리 객체를 정의
abstract class DrinkFactory {
  // Drinkable 객체를 return 하는 함수를 갖는다
  Drinkable createDrink();
}

// Pub 객체를 정의
// DrinkFactory 추상 클래스를 구현
class Pub implements DrinkFactory {
  // Beer를 만들어 주는 함수를 구현
  Drinkable createDrink() {
    return Beer();
  }
}

// CoffeeShop 객체를 정의
// Pub과 마찬가지로 DrinkFactory에는 두 종류의 구현 객체가 존재
class CoffeeShop implements DrinkFactory {
  Drinkable createDrink() {
    return Coffee();
  }
}

void main() {
  // 기분을 설정
  var mood = "sleepy";
  DrinkFactory destination;

  // 기분에 따라 생성되는 객체가 달라짐
  switch (mood) {
    case "sleepy":
      destination = CoffeeShop();
      break;
    case "done":
      destination = Pub();
      break;
    default:
      print("I only have two moods...");
  }

  // 음료를 생성
  var myBeverage = destination.createDrink();
  // 부으면 음료에 따라 호출되는 내용이 달라짐
  myBeverage.pour();
}
</code></pre>
<h3 id="factory-method">Factory Method</h3>
<ul>
<li>팩토리 메서드 패턴은 생성 될 객체의 정확한 클래스를 지정하지 않고도 팩토리 메소드를 사용하여 개체를 만드는 문제를 처리하는 생성 패턴입니다.</li>
</ul>
<pre><code class="language-dart">class Volume {
  // 상수 변수 두개 선언
  final int quantity;
  final String unit;

  // 생성자 지정
  Volume(this.quantity, this.unit);
  String toString() => "$quantity $unit";
}

// 추상 클래스 정의
abstract class Vessel {
  Volume volume;
  String liquid;
}

// Vessel을 상속받은 Bucket 정의
class Bucket extends Vessel {
  final Volume volume;

  // 생성자에서 받은 인자를 Volumn 생성자에 넘겨줌 값을 내부 변수 volume에 대입
  Bucket(int q, String u) : volume = Volume(q, u);
  // toString 함수 정의
  String toString() => "a $volume bucket full of $liquid";
}

class Cup extends Vessel {
  final Volume volume;

  Cup(int q, String u) : volume = Volume(q, u);
  String toString() => "a $volume cup full of $liquid";
}

// '피로'라는 enum 정의
enum Tiredness {
  // 휴식, 졸림, 겨우 살아있음, 아이가 있다(말 못할 고통??)
  rested,
  sleepy,
  barelyAlive,
  hasChildren
}

// 커피 용기 공장 함수 정의
class CoffeeVesselFactory {
  // 전역 함수 정의
  static Vessel vesselFor(Tiredness howTired) {
    Vessel vessel;
    // 얼마나 피곤하지에 따라서 용기의 양이 달라짐
    switch (howTired) {
      case Tiredness.rested:
        vessel = Cup(100, "milliliter");
        break;
      case Tiredness.sleepy:
      case Tiredness.barelyAlive:
        vessel = Cup(500, "milliliter");
        break;
      case Tiredness.hasChildren:
        vessel = Bucket(5, "liter");
        break;
      default:
        vessel = Cup(200, "milliliter");
        break;
    }
    // 액체는 모두 다 커피
    vessel.liquid = "coffee";
    return vessel;
  }
}

void main() {
  var sleepyVessel = CoffeeVesselFactory.vesselFor(Tiredness.sleepy);
  var kidVessel = CoffeeVesselFactory.vesselFor(Tiredness.hasChildren);

  // A sleepy person would like a 500 milliliter cup full of coffee.
  print("A sleepy person would like $sleepyVessel.");
  // A person with children NEEDS a 5 liter bucket full of coffee.
  print("A person with children NEEDS $kidVessel.");
}

</code></pre>
<h3 id="builder">Builder</h3>
<ul>
<li>Builder 디자인 패턴의 목적은 복잡한 객체의 구성과 표현을 분리하는 것입니다.</li>
<li>이런식으로 같은 생성 방식으로 다른 객체들을 만들 수 있습니다.</li>
</ul>
<pre><code class="language-dart">class PizzaBuilder {
  // 빵 껍질
  String _crust;
  // 지름
  int _diameter;
  // 구성들
  Set&#x3C;String> _toppings;

  PizzaBuilder(this._diameter);

  // getter
  String get crust => _crust;
  // setter
  set crust(String newCrust) {
    _crust = newCrust;
  }

  int get diameter => _diameter;
  set diameter(int newDiameter) {
    _diameter = newDiameter;
  }

  Set&#x3C;String> get toppings => _toppings;
  set toppings(Set&#x3C;String> newToppings) {
    _toppings = newToppings;
    _ensureCheese();
  }

  // 치즈 추가
  void _ensureCheese() {
    _toppings.add("cheese");
  }

  Pizza build() {
    return Pizza(this);
  }
}

class Pizza {
  String _crust;
  int _diameter;
  Set&#x3C;String> _toppings;

  Pizza(PizzaBuilder builder) {
    _crust = builder.crust;
    _diameter = builder.diameter;
    _toppings = builder.toppings;
  }

  String get crust => _crust;
  int get diameter => _diameter;
  String get toppings => _stringifiedToppings();
  // 토핑 목록을 ", "으로 연결된 문자열로 변환
  String _stringifiedToppings() {
    var stringToppings = _toppings.join(", ");
    var lastComma = stringToppings.lastIndexOf(",");
    var replacement =
        ",".allMatches(stringToppings).length > 1 ? ", and" : " and";

    return stringToppings.replaceRange(lastComma, lastComma + 1, replacement);
  }

  @override
  String toString() {
    return "A delicious $_diameter\" pizza with $_crust crust covered in $toppings";
  }
}

void main() {
  /**
   * * pizzaBuilder에 속성들을 집어넣은 후
   * * Pizza 객체 생성자에 pizzaBuilder를 넣어 생성하면 완성된 피자가 만들어진다.
   */
  // Create a handy PizzaBuilder with an 8" diameter.
  var pizzaBuilder = PizzaBuilder(8);

  // Add some attributes to the builder.
  pizzaBuilder.crust = "deep dish";
  pizzaBuilder.toppings = Set.from(["pepperoni"]);

  // Let's make a pizza!
  var plainPizza = Pizza(pizzaBuilder);
  print("Behold! $plainPizza");
  assert(plainPizza.toString() ==
      "A delicious 8\" pizza with deep dish crust covered in pepperoni and cheese");

  // Now to adjust some things for the next pizza...
  pizzaBuilder.crust = "gold plated";
  pizzaBuilder.diameter = 72;
  pizzaBuilder.toppings = Set.from(["anchovies", "caviar", "diamonds"]);

  // The beauty of the build is you can quickly iterate and produce instances of a class.
  // For example, we have an early employee of the latest unicorn in line. So much disposable income!
  // Also note, we use the .build() function of the builder this time.
  var luxuriousPizza = pizzaBuilder.build();
  print("Wow! $luxuriousPizza? Somone is rich!");
  assert(luxuriousPizza.toString() ==
      "A delicious 72\" pizza with gold plated crust covered in anchovies, caviar, diamonds, and cheese");
}

</code></pre>
<h3 id="prototype">Prototype</h3>
<ul>
<li>프로토타입 방식은 새 객체를 생성하기 위해 복제되는 원형 객체에 의해 결정됩니다.</li>
<li>이 패턴은 이럴 때 사용됩니다.
<ul>
<li>애플리케이션에서 팩토리 메서드 방식이 하는 것처럼 객체 생성자의 하위 클래스를 피할 때</li>
<li>애플리케이션에서 기본 방식으로(예 new 키워드 사용) 새 객체 생성이 엄청나게 많은 비용이 발생하는 경우를 피하기 위해</li>
</ul>
</li>
<li>이 방식을 구현하려면, 순수한 가상 clone() 함수를 정의한 기본 추상 클래스를 선언하세요. 추상 클래스에서 파생된 "다형 생성자" 기능이 필요한 클래스는 clone() 함수를 구현해야합니다.</li>
</ul>
<pre><code class="language-dart">abstract class Shape {
  int x;
  int y;
  Shape clone();
}

class Rectangle implements Shape {
  int height;
  int width;
  int x;
  int y;

  int _hashCode;
  bool isClone = false;
  String get cloneStatus => isClone ? "is a clone" : "is an original gangster";

  Rectangle(this.height, this.width, this.x, this.y);

  Rectangle.fromSource(Rectangle source) {
    height = source.height;
    width = source.width;
    x = source.x;
    y = source.y;
    _hashCode = source.hashCode;
    isClone = true;
  }

  @override
  Rectangle clone() {
    return Rectangle.fromSource(this);
  }

  @override
  int get hashCode {
    if (_hashCode != null) return _hashCode;
    _hashCode = DateTime.now().microsecondsSinceEpoch;
    return _hashCode;
  }

  @override
  bool operator ==(dynamic other) {
    if (other is Rectangle) return false;
    Rectangle rect = other;
    return rect.isClone &#x26;&#x26; rect.hashCode == hashCode;
  }
}

void main() {
  var ogRect = Rectangle(0, 0, 100, 100);
  var cloneRect = ogRect.clone();
  var someOtherRect = Rectangle(0, 0, 100, 100);

  print("ogRect ${ogRect.cloneStatus}.");
  print("cloneRect ${cloneRect.cloneStatus}.");
  print("someOtherRect ${someOtherRect.cloneStatus}.");

  String cloneIsClonse =
      ogRect == cloneRect ? "is a clone of" : "is not a clone of";
  print("\r\ncloneRect $cloneIsClonse ogRect");

  String someRectIsClone =
      ogRect == someOtherRect ? "is a clone of" : "is not a clone of";
  print("someOtherRect $someRectIsClone ogRect");
}
</code></pre>
<h3 id="singleton">Singleton</h3>
<ul>
<li>싱글톤 패턴은 클래스의 구현을 단 하나만 생성되기로 제한한 방식입니다. 시스템 내에서 한 객체만 필요한 경우 유용합니다.
<ul>
<li>Abstract factory, Builder, Prototype 패턴은 구현에 singleton으로 사용할 수 있습니다.</li>
<li>Facade 객체는 종종 하나의 facade 객체만을 필요로 하기 때문에 singleton입니다.</li>
<li>State 객체는 종종 singleton입니다.</li>
</ul>
</li>
<li>싱글톤 패턴은 전역변수로 자주 사용됩니다.</li>
</ul>
<pre><code class="language-dart">class Me {
  static final Me _singleton = new Me._internal();
  static final String _name = "Typer";

  // 생성자 함수
  factory Me() {
    return _singleton;
  }

  static String get name => _name;

  @override
  String toString() => "Hello, my name is $name";

  // private 생성자, 아무 이름이나 지정 가능
  Me._internal();
}

void main() {
  var tyler = Me();
  var anotherTyler = Me();

  print(tyler);
  print(anotherTyler);

  var samenessCheck = identical(tyler, anotherTyler)
      ? "We are both the same ${Me.name}"
      : "We are NOT the same. I mean, just look at us.";
  print(samenessCheck);
}
</code></pre>
<h1 id="구조structural-패턴">구조(Structural) 패턴</h1>
<ul>
<li>여러 개의 객체를 모아 구조화시키는 패턴이다.</li>
<li>여러 개의 객체를 접근할 수 있는 인터페이스를 제공한다.</li>
<li>여러 개의 객체를 모아 새로운 기능을 제공하게 한다.</li>
</ul>
<h2 id="종류-1">종류</h2>
<p>7개</p>
<h3 id="adapter">Adapter</h3>
<ul>
<li>USB 장치, HDMI처럼 호환되지 않는 두 인터페이스를 이어주는 역할</li>
</ul>
<pre><code class="language-dart">const adapteeMessage = 'Adaptee#method was called';

class Adaptee {
  String method() {
    print('Adaptee#method is being called');

    return adapteeMessage;
  }
}

// 추상 클래스
abstract class Target {
  String call();
}

class Adapter implements Target {
  @override
  String call() {
    // Adapter 함수 안에서 Adaptee 클래스 인스턴스 생성
    var adaptee = Adaptee();
    print('Adapter#call is being called');
    return adaptee.method();
  }
}

void main(List&#x3C;String> arguments) {
  // Adapter 클래스 인스턴스 생성
  var adapter = Adapter();
  // call 함수 결과 반환
  var result = adapter.call();
  // 결과와 메세지가 같은지 비교
  assert(result == adapteeMessage);
}
</code></pre>
<h3 id="bridge">Bridge</h3>
<ul>
<li>두 개가 독립적으로 다를 수 있도록 구현에서 추상화를 분리하는 것.</li>
<li>브릿지 패턴은 캡슐화, aggregation을 사용하고 책임을 다른 클래스로 구분하기 위해 상속을 사용할 수 있습니다.</li>
<li>브릿지는 어댑터와 자주 혼동됩니다.</li>
</ul>
<h3 id="composite">Composite</h3>
<h3 id="decorator">Decorator</h3>
<h3 id="facade">Facade</h3>
<h3 id="flyweight">Flyweight</h3>
<h3 id="proxy">Proxy</h3>
<h1 id="행위behavioral-패턴">행위(Behavioral) 패턴</h1>
<ul>
<li>객체의 구체적인 알고리즘을 정의하는 패턴이다.</li>
<li>큰 작업을 여러 개의 객체로 분리한 방법을 제공한다.</li>
<li>반복적으로 사용하는 객체들의 상호 작용을 패턴화한 것으로 객체의 행위를 조직화, 관리, 연합하는데 사용되는 패턴이다.</li>
<li>객체 사이의 결합도를 최소화한다.</li>
<li>알고리즘 수행에 주로 사용된다.</li>
</ul>
<h2 id="종류-2">종류</h2>
<p>10개</p>
<h3 id="chain-of-responsibility">Chain of Responsibility</h3>
<h3 id="command">Command</h3>
<h3 id="interpreter">Interpreter</h3>
<h3 id="iterator">Iterator</h3>
<h3 id="mediator">Mediator</h3>
<h3 id="memento">Memento</h3>
<h3 id="observer">Observer</h3>
<h3 id="state">State</h3>
<h3 id="strategy">Strategy</h3>
<h3 id="template-method">Template Method</h3>
<h3 id="visitor">Visitor</h3>
</body>
</html>
</article></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"GoF(Gang of Four) Design Patterns 정리","date":"2021-01-17","slug":"methodology/2021/gof-design-patterns/index","content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003ctitle\u003eContents\u003c/title\u003e\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e정보처리기사책을 공부하다 보면 나오는 GoF 디자인 패턴이 나옵니다.\u003c/p\u003e\n\u003cp\u003e예제가 있으면 이해가 쉬울거 같아 정리를 해봅니다.\u003c/p\u003e\n\u003cp\u003e저는 Dart언어를 좋아해서 구글링을 해보니 이미 누군가가 정리해 놓은 글이 있어 인용합니다. \u003ca href=\"https://scottt2.github.io/design-patterns-in-dart/\"\u003eDart로 구현한 Degisn Patterns\u003c/a\u003e\u003c/p\u003e\n\u003ch1 id=\"생성creational-패턴\"\u003e생성(Creational) 패턴\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e객체를 생성하는 데 사용되는 패턴이다.\u003c/li\u003e\n\u003cli\u003e클래스 정의와 객체 생성 방식을 구조화, 캡슐화한 방법을 제사한다.\u003c/li\u003e\n\u003cli\u003e객체를 생성하거나 수정되어도 프로그램 구조에 영향을 적게 받도록 한다.\u003c/li\u003e\n\u003cli\u003e캡슐화하여 부작용을 최소화한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"종류\"\u003e종류\u003c/h2\u003e\n\u003cp\u003e5개\u003c/p\u003e\n\u003ch3 id=\"abstract-facotry\"\u003eAbstract Facotry\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e추상 팩토리 패턴은 구체적인 클래스를 지정하지 않고 공통된 주제를 가진 개별 팩토리 그룹을 캡슐화하는 방법을 제공한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-dart\"\u003e// '마실 수 있는' 추상형태를 가진 추상 클래스 정의\nabstract class Drinkable {\n  void pour(); // '붓다'라는 함수를 갖는다\n}\n\n// Beer 객체를 정의\n// Drinkable 추상 클래스를 구현해 추상 팩토리에서 활용할 수 있는 객체로 만듦\nclass Beer implements Drinkable {\n  // 함수를 구현\n  void pour() {\n    print(\"Pouring a delicious beer!\");\n  }\n}\n\n// Coffee 객체를 정의\n// Beer와 마찬가지로 Drinkable에는 두 종류의 구현 객체가 존재\nclass Coffee implements Drinkable {\n  void pour() {\n    print(\"Pouring a refreshing coffee!\");\n  }\n}\n\n// 추상 팩토리 객체를 정의\nabstract class DrinkFactory {\n  // Drinkable 객체를 return 하는 함수를 갖는다\n  Drinkable createDrink();\n}\n\n// Pub 객체를 정의\n// DrinkFactory 추상 클래스를 구현\nclass Pub implements DrinkFactory {\n  // Beer를 만들어 주는 함수를 구현\n  Drinkable createDrink() {\n    return Beer();\n  }\n}\n\n// CoffeeShop 객체를 정의\n// Pub과 마찬가지로 DrinkFactory에는 두 종류의 구현 객체가 존재\nclass CoffeeShop implements DrinkFactory {\n  Drinkable createDrink() {\n    return Coffee();\n  }\n}\n\nvoid main() {\n  // 기분을 설정\n  var mood = \"sleepy\";\n  DrinkFactory destination;\n\n  // 기분에 따라 생성되는 객체가 달라짐\n  switch (mood) {\n    case \"sleepy\":\n      destination = CoffeeShop();\n      break;\n    case \"done\":\n      destination = Pub();\n      break;\n    default:\n      print(\"I only have two moods...\");\n  }\n\n  // 음료를 생성\n  var myBeverage = destination.createDrink();\n  // 부으면 음료에 따라 호출되는 내용이 달라짐\n  myBeverage.pour();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"factory-method\"\u003eFactory Method\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e팩토리 메서드 패턴은 생성 될 객체의 정확한 클래스를 지정하지 않고도 팩토리 메소드를 사용하여 개체를 만드는 문제를 처리하는 생성 패턴입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-dart\"\u003eclass Volume {\n  // 상수 변수 두개 선언\n  final int quantity;\n  final String unit;\n\n  // 생성자 지정\n  Volume(this.quantity, this.unit);\n  String toString() =\u003e \"$quantity $unit\";\n}\n\n// 추상 클래스 정의\nabstract class Vessel {\n  Volume volume;\n  String liquid;\n}\n\n// Vessel을 상속받은 Bucket 정의\nclass Bucket extends Vessel {\n  final Volume volume;\n\n  // 생성자에서 받은 인자를 Volumn 생성자에 넘겨줌 값을 내부 변수 volume에 대입\n  Bucket(int q, String u) : volume = Volume(q, u);\n  // toString 함수 정의\n  String toString() =\u003e \"a $volume bucket full of $liquid\";\n}\n\nclass Cup extends Vessel {\n  final Volume volume;\n\n  Cup(int q, String u) : volume = Volume(q, u);\n  String toString() =\u003e \"a $volume cup full of $liquid\";\n}\n\n// '피로'라는 enum 정의\nenum Tiredness {\n  // 휴식, 졸림, 겨우 살아있음, 아이가 있다(말 못할 고통??)\n  rested,\n  sleepy,\n  barelyAlive,\n  hasChildren\n}\n\n// 커피 용기 공장 함수 정의\nclass CoffeeVesselFactory {\n  // 전역 함수 정의\n  static Vessel vesselFor(Tiredness howTired) {\n    Vessel vessel;\n    // 얼마나 피곤하지에 따라서 용기의 양이 달라짐\n    switch (howTired) {\n      case Tiredness.rested:\n        vessel = Cup(100, \"milliliter\");\n        break;\n      case Tiredness.sleepy:\n      case Tiredness.barelyAlive:\n        vessel = Cup(500, \"milliliter\");\n        break;\n      case Tiredness.hasChildren:\n        vessel = Bucket(5, \"liter\");\n        break;\n      default:\n        vessel = Cup(200, \"milliliter\");\n        break;\n    }\n    // 액체는 모두 다 커피\n    vessel.liquid = \"coffee\";\n    return vessel;\n  }\n}\n\nvoid main() {\n  var sleepyVessel = CoffeeVesselFactory.vesselFor(Tiredness.sleepy);\n  var kidVessel = CoffeeVesselFactory.vesselFor(Tiredness.hasChildren);\n\n  // A sleepy person would like a 500 milliliter cup full of coffee.\n  print(\"A sleepy person would like $sleepyVessel.\");\n  // A person with children NEEDS a 5 liter bucket full of coffee.\n  print(\"A person with children NEEDS $kidVessel.\");\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"builder\"\u003eBuilder\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eBuilder 디자인 패턴의 목적은 복잡한 객체의 구성과 표현을 분리하는 것입니다.\u003c/li\u003e\n\u003cli\u003e이런식으로 같은 생성 방식으로 다른 객체들을 만들 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-dart\"\u003eclass PizzaBuilder {\n  // 빵 껍질\n  String _crust;\n  // 지름\n  int _diameter;\n  // 구성들\n  Set\u0026#x3C;String\u003e _toppings;\n\n  PizzaBuilder(this._diameter);\n\n  // getter\n  String get crust =\u003e _crust;\n  // setter\n  set crust(String newCrust) {\n    _crust = newCrust;\n  }\n\n  int get diameter =\u003e _diameter;\n  set diameter(int newDiameter) {\n    _diameter = newDiameter;\n  }\n\n  Set\u0026#x3C;String\u003e get toppings =\u003e _toppings;\n  set toppings(Set\u0026#x3C;String\u003e newToppings) {\n    _toppings = newToppings;\n    _ensureCheese();\n  }\n\n  // 치즈 추가\n  void _ensureCheese() {\n    _toppings.add(\"cheese\");\n  }\n\n  Pizza build() {\n    return Pizza(this);\n  }\n}\n\nclass Pizza {\n  String _crust;\n  int _diameter;\n  Set\u0026#x3C;String\u003e _toppings;\n\n  Pizza(PizzaBuilder builder) {\n    _crust = builder.crust;\n    _diameter = builder.diameter;\n    _toppings = builder.toppings;\n  }\n\n  String get crust =\u003e _crust;\n  int get diameter =\u003e _diameter;\n  String get toppings =\u003e _stringifiedToppings();\n  // 토핑 목록을 \", \"으로 연결된 문자열로 변환\n  String _stringifiedToppings() {\n    var stringToppings = _toppings.join(\", \");\n    var lastComma = stringToppings.lastIndexOf(\",\");\n    var replacement =\n        \",\".allMatches(stringToppings).length \u003e 1 ? \", and\" : \" and\";\n\n    return stringToppings.replaceRange(lastComma, lastComma + 1, replacement);\n  }\n\n  @override\n  String toString() {\n    return \"A delicious $_diameter\\\" pizza with $_crust crust covered in $toppings\";\n  }\n}\n\nvoid main() {\n  /**\n   * * pizzaBuilder에 속성들을 집어넣은 후\n   * * Pizza 객체 생성자에 pizzaBuilder를 넣어 생성하면 완성된 피자가 만들어진다.\n   */\n  // Create a handy PizzaBuilder with an 8\" diameter.\n  var pizzaBuilder = PizzaBuilder(8);\n\n  // Add some attributes to the builder.\n  pizzaBuilder.crust = \"deep dish\";\n  pizzaBuilder.toppings = Set.from([\"pepperoni\"]);\n\n  // Let's make a pizza!\n  var plainPizza = Pizza(pizzaBuilder);\n  print(\"Behold! $plainPizza\");\n  assert(plainPizza.toString() ==\n      \"A delicious 8\\\" pizza with deep dish crust covered in pepperoni and cheese\");\n\n  // Now to adjust some things for the next pizza...\n  pizzaBuilder.crust = \"gold plated\";\n  pizzaBuilder.diameter = 72;\n  pizzaBuilder.toppings = Set.from([\"anchovies\", \"caviar\", \"diamonds\"]);\n\n  // The beauty of the build is you can quickly iterate and produce instances of a class.\n  // For example, we have an early employee of the latest unicorn in line. So much disposable income!\n  // Also note, we use the .build() function of the builder this time.\n  var luxuriousPizza = pizzaBuilder.build();\n  print(\"Wow! $luxuriousPizza? Somone is rich!\");\n  assert(luxuriousPizza.toString() ==\n      \"A delicious 72\\\" pizza with gold plated crust covered in anchovies, caviar, diamonds, and cheese\");\n}\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"prototype\"\u003ePrototype\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e프로토타입 방식은 새 객체를 생성하기 위해 복제되는 원형 객체에 의해 결정됩니다.\u003c/li\u003e\n\u003cli\u003e이 패턴은 이럴 때 사용됩니다.\n\u003cul\u003e\n\u003cli\u003e애플리케이션에서 팩토리 메서드 방식이 하는 것처럼 객체 생성자의 하위 클래스를 피할 때\u003c/li\u003e\n\u003cli\u003e애플리케이션에서 기본 방식으로(예 new 키워드 사용) 새 객체 생성이 엄청나게 많은 비용이 발생하는 경우를 피하기 위해\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e이 방식을 구현하려면, 순수한 가상 clone() 함수를 정의한 기본 추상 클래스를 선언하세요. 추상 클래스에서 파생된 \"다형 생성자\" 기능이 필요한 클래스는 clone() 함수를 구현해야합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-dart\"\u003eabstract class Shape {\n  int x;\n  int y;\n  Shape clone();\n}\n\nclass Rectangle implements Shape {\n  int height;\n  int width;\n  int x;\n  int y;\n\n  int _hashCode;\n  bool isClone = false;\n  String get cloneStatus =\u003e isClone ? \"is a clone\" : \"is an original gangster\";\n\n  Rectangle(this.height, this.width, this.x, this.y);\n\n  Rectangle.fromSource(Rectangle source) {\n    height = source.height;\n    width = source.width;\n    x = source.x;\n    y = source.y;\n    _hashCode = source.hashCode;\n    isClone = true;\n  }\n\n  @override\n  Rectangle clone() {\n    return Rectangle.fromSource(this);\n  }\n\n  @override\n  int get hashCode {\n    if (_hashCode != null) return _hashCode;\n    _hashCode = DateTime.now().microsecondsSinceEpoch;\n    return _hashCode;\n  }\n\n  @override\n  bool operator ==(dynamic other) {\n    if (other is Rectangle) return false;\n    Rectangle rect = other;\n    return rect.isClone \u0026#x26;\u0026#x26; rect.hashCode == hashCode;\n  }\n}\n\nvoid main() {\n  var ogRect = Rectangle(0, 0, 100, 100);\n  var cloneRect = ogRect.clone();\n  var someOtherRect = Rectangle(0, 0, 100, 100);\n\n  print(\"ogRect ${ogRect.cloneStatus}.\");\n  print(\"cloneRect ${cloneRect.cloneStatus}.\");\n  print(\"someOtherRect ${someOtherRect.cloneStatus}.\");\n\n  String cloneIsClonse =\n      ogRect == cloneRect ? \"is a clone of\" : \"is not a clone of\";\n  print(\"\\r\\ncloneRect $cloneIsClonse ogRect\");\n\n  String someRectIsClone =\n      ogRect == someOtherRect ? \"is a clone of\" : \"is not a clone of\";\n  print(\"someOtherRect $someRectIsClone ogRect\");\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"singleton\"\u003eSingleton\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e싱글톤 패턴은 클래스의 구현을 단 하나만 생성되기로 제한한 방식입니다. 시스템 내에서 한 객체만 필요한 경우 유용합니다.\n\u003cul\u003e\n\u003cli\u003eAbstract factory, Builder, Prototype 패턴은 구현에 singleton으로 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eFacade 객체는 종종 하나의 facade 객체만을 필요로 하기 때문에 singleton입니다.\u003c/li\u003e\n\u003cli\u003eState 객체는 종종 singleton입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e싱글톤 패턴은 전역변수로 자주 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-dart\"\u003eclass Me {\n  static final Me _singleton = new Me._internal();\n  static final String _name = \"Typer\";\n\n  // 생성자 함수\n  factory Me() {\n    return _singleton;\n  }\n\n  static String get name =\u003e _name;\n\n  @override\n  String toString() =\u003e \"Hello, my name is $name\";\n\n  // private 생성자, 아무 이름이나 지정 가능\n  Me._internal();\n}\n\nvoid main() {\n  var tyler = Me();\n  var anotherTyler = Me();\n\n  print(tyler);\n  print(anotherTyler);\n\n  var samenessCheck = identical(tyler, anotherTyler)\n      ? \"We are both the same ${Me.name}\"\n      : \"We are NOT the same. I mean, just look at us.\";\n  print(samenessCheck);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"구조structural-패턴\"\u003e구조(Structural) 패턴\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e여러 개의 객체를 모아 구조화시키는 패턴이다.\u003c/li\u003e\n\u003cli\u003e여러 개의 객체를 접근할 수 있는 인터페이스를 제공한다.\u003c/li\u003e\n\u003cli\u003e여러 개의 객체를 모아 새로운 기능을 제공하게 한다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"종류-1\"\u003e종류\u003c/h2\u003e\n\u003cp\u003e7개\u003c/p\u003e\n\u003ch3 id=\"adapter\"\u003eAdapter\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eUSB 장치, HDMI처럼 호환되지 않는 두 인터페이스를 이어주는 역할\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"language-dart\"\u003econst adapteeMessage = 'Adaptee#method was called';\n\nclass Adaptee {\n  String method() {\n    print('Adaptee#method is being called');\n\n    return adapteeMessage;\n  }\n}\n\n// 추상 클래스\nabstract class Target {\n  String call();\n}\n\nclass Adapter implements Target {\n  @override\n  String call() {\n    // Adapter 함수 안에서 Adaptee 클래스 인스턴스 생성\n    var adaptee = Adaptee();\n    print('Adapter#call is being called');\n    return adaptee.method();\n  }\n}\n\nvoid main(List\u0026#x3C;String\u003e arguments) {\n  // Adapter 클래스 인스턴스 생성\n  var adapter = Adapter();\n  // call 함수 결과 반환\n  var result = adapter.call();\n  // 결과와 메세지가 같은지 비교\n  assert(result == adapteeMessage);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"bridge\"\u003eBridge\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e두 개가 독립적으로 다를 수 있도록 구현에서 추상화를 분리하는 것.\u003c/li\u003e\n\u003cli\u003e브릿지 패턴은 캡슐화, aggregation을 사용하고 책임을 다른 클래스로 구분하기 위해 상속을 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e브릿지는 어댑터와 자주 혼동됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"composite\"\u003eComposite\u003c/h3\u003e\n\u003ch3 id=\"decorator\"\u003eDecorator\u003c/h3\u003e\n\u003ch3 id=\"facade\"\u003eFacade\u003c/h3\u003e\n\u003ch3 id=\"flyweight\"\u003eFlyweight\u003c/h3\u003e\n\u003ch3 id=\"proxy\"\u003eProxy\u003c/h3\u003e\n\u003ch1 id=\"행위behavioral-패턴\"\u003e행위(Behavioral) 패턴\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e객체의 구체적인 알고리즘을 정의하는 패턴이다.\u003c/li\u003e\n\u003cli\u003e큰 작업을 여러 개의 객체로 분리한 방법을 제공한다.\u003c/li\u003e\n\u003cli\u003e반복적으로 사용하는 객체들의 상호 작용을 패턴화한 것으로 객체의 행위를 조직화, 관리, 연합하는데 사용되는 패턴이다.\u003c/li\u003e\n\u003cli\u003e객체 사이의 결합도를 최소화한다.\u003c/li\u003e\n\u003cli\u003e알고리즘 수행에 주로 사용된다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"종류-2\"\u003e종류\u003c/h2\u003e\n\u003cp\u003e10개\u003c/p\u003e\n\u003ch3 id=\"chain-of-responsibility\"\u003eChain of Responsibility\u003c/h3\u003e\n\u003ch3 id=\"command\"\u003eCommand\u003c/h3\u003e\n\u003ch3 id=\"interpreter\"\u003eInterpreter\u003c/h3\u003e\n\u003ch3 id=\"iterator\"\u003eIterator\u003c/h3\u003e\n\u003ch3 id=\"mediator\"\u003eMediator\u003c/h3\u003e\n\u003ch3 id=\"memento\"\u003eMemento\u003c/h3\u003e\n\u003ch3 id=\"observer\"\u003eObserver\u003c/h3\u003e\n\u003ch3 id=\"state\"\u003eState\u003c/h3\u003e\n\u003ch3 id=\"strategy\"\u003eStrategy\u003c/h3\u003e\n\u003ch3 id=\"template-method\"\u003eTemplate Method\u003c/h3\u003e\n\u003ch3 id=\"visitor\"\u003eVisitor\u003c/h3\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["methodology","2021","gof-design-patterns","index"]},"buildId":"h_iCwTpJA7YjAPN2rGkKn","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>