<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/24f5c4934916282a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/24f5c4934916282a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-591bb7ec51acdc0d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-22f980d027594622.js" defer=""></script><script src="/_next/static/chunks/675-717e3cc8fb67a947.js" defer=""></script><script src="/_next/static/chunks/194-b74e21e59d8a75e2.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-e07d71ec7cb54eb2.js" defer=""></script><script src="/_next/static/48cndNy0EEL7Rh6WrBUSX/_buildManifest.js" defer=""></script><script src="/_next/static/48cndNy0EEL7Rh6WrBUSX/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="absolute w-full pt-3"><div class="container mx-auto flex flex-wrap"><a class="w-2/6 text-lg font-bold" href="/">🌎 Sunhwang&#x27;s blog</a><ul class="flex grow justify-between"><li><a class="hover:underline hover:underline-offset-8 " href="/categories">Categories</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/tags">Tags</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/books">Books</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/about">About me</a></li></ul></div></nav><main><div class="container mx-auto pt-10"><article class="mb-32"><h1 class="mb-12 text-center text-5xl font-bold leading-tight tracking-tighter md:text-left md:text-7xl md:leading-none lg:text-4xl">MapStruct 에러 해결 첫번째</h1><div class="mb-8 sm:mx-0 md:mb-16"><div class="sm:mx-0"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0"><img alt="Cover Image for MapStruct 에러 해결 첫번째" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="shadow-sm" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Cover Image for MapStruct 에러 해결 첫번째" src="" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="shadow-sm" loading="lazy"/></noscript></span></div></div><div class="mx-auto max-w-2xl"><div class="mb-6 text-lg"><time dateTime="2020-08-07">August	7, 2020</time></div></div><div class="mx-auto max-w-2xl"><div class="markdown-styles_markdown__h_8de"><p>Mapstruct를 실무에 사용해보면서 겪은 경험을 공유하고자 합니다.</p>
<p><a href="https://mapstruct.org/">MapStruct</a>에 Get Started에는 정말 간단하게 설명되어 있습니다.
DTO &#x3C;-> Entity를 변경해주는 간단한 library 이지만 확장성은 대단합니다.</p>
<p>단순 작업을 build 단계에서 생성해주어 {Entity}Mapper interface를 {Entity}MapperImpl로 만들어줍니다.</p>
<p>예를 들어 User Entity에 UserRole이 있다고 가정 해보겠습니다.</p>
<p>공식 홈페이지에 더 자세한 설명이 있지만 저희 프로젝트에서 사용하는 모습은 이렇습니다.</p>
<pre><code>@Mapper(uses = {UserRoleMapper.class}, unmappedTargetPolicy = ReportingPolicy.ERROR, nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT)
public interface UserMapper {

  /**
   * UserMapper는 연관 Entity Mapper를 사용합니다. users 속한 Mapper 에는 @Mapping(target = "user", ignore = true) 설정 되어있습니다.
   */
  UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

  UserDTO toDTO(User user);

  User toEntity(UserDTO userDTO);
</code></pre>
<p>@Mapper annotation에 적힌 부분을 설명드리겠습니다.</p>
<p>users - 다른 Mapper 파일을 참조하려고 할 때, 사용됩니다.</p>
<p>users에 사용된 UserRoleMapper.class입니다.</p>
<pre><code>@Mapper(uses = {RoleMapper.class}, unmappedTargetPolicy = ReportingPolicy.ERROR, nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT)
public interface UserRoleMapper {

  UserRoleMapper INSTANCE = Mappers.getMapper(UserRoleMapper.class);

  @Mapping(target = "user", ignore = true)
  UserRoleDTO toDTO(UserRole userRole);

  @Mapping(target = "user", ignore = true)
  UserRole toEntity(UserRoleDTO userRoleDTO);
}
</code></pre>
<p>UserRoleMapper에선 UserRole 안에 있는 user가 변환되는걸 막아야 무한 참조에 빠지지 않습니다.</p>
<p>그리고 User가 저장되는 기준으로 Entity변환 후 UserRole을 setUserRole 함수를 이용해 담아 주시면 저장이 되어 아직 문제가 된 상황은 발견하지 못했습니다.<br>
아직 발견하지 못한 문제가 있을 수 있습니다.(저도 알고싶어요..)</p>
<p>unmappedTargetPolicy - DTO와 Entity에 선언된 변수들이 ignore = true로 되어있지 않은 변수가 변환이 안되는 경우 에러가 나며 Run 되지 않게합니다.</p>
<p>nullValueMappingStrategy - null인 변수를 초기화 해줍니다. Entity로 변환된 객체에서 .get{OtherEntity}()를 할때 NullpointException을 방지해줍니다.</p>
<h4>변경사항 2020.08.12</h4>
<p>nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT)를 사용한 Mapper를 이용해 JPA Repository .save(Entity 구현 객체)함수를 실행했지만 이상한 동작이 생겼습니다.<br>
문제는 위 설정을 통해 항상 NullPointException을 방지하고자 객체를 만듭니다.<br>
그런 경우 JPA쪽에서 새로운 객체가 생성되고 연관 객체도 Null이 아니여서 Null이 아니지만 텅 빈 객체가 저장될 경우에도 insert를 시도하려고 합니다.<br>
이러한 상황때문에 거의 모든 경우에 저 설정을 해제했습니다.</p>
<hr>
<p>public abstract class UserMapper로 만들어서 beforeMapping이나 afterMapping을 통해 제어도 가능하지만,<br>
한 파일에 다른 Entity작업을 몰아주는 것이 옳은 것인가 하는 생각이 들어서 각 Entity마다 Mapper를 만들었습니다.</p>
<p>그래서 Domain별 파일구조는</p>
<ul>
<li>{domain}
<ul>
<li>controller</li>
<li>model
<ul>
<li>dto</li>
<li>entity</li>
<li>mapper &#x3C;- 여기에 MapStruct 파일이 domain별로 들어가 있습니다.</li>
<li>validator</li>
</ul>
</li>
<li>repository</li>
<li>service</li>
</ul>
</li>
</ul>
<p>이런 파일구조로 되어 있습니다.</p>
<p>UserMapper.INSTANCE.toEntity, toDTO 함수는 DDD패턴으로 각 Entity에서 수행하도록 함수를 구현해줍니다.</p>
<pre><code>@Entity
public class User {

    ... 다른 부분 생략

    public static User toEntity(UserDTO userDTO) {
        return UserMapper.INSTANCE.toEntity(userDTO);
    }
}
</code></pre>
<p>DTO &#x3C;-> Entity를 변환해주는 작업을 하게되면 User 객체 (DTO, Entity) 안에는 <code>List&#x3C;UserRoleDTO> userRoles, Set&#x3C;UserRole> userRoles</code>로 되어있는 부분까지도 변환을 해줍니다.</p>
<blockquote>
<p>그러나 Request 요청으로 넘어온 UserDTO 객체 안에 userRoles를 순서대로 넣고싶은 경우 어떻게 할까요?
왜 DTO는 List interface이고 Entity에는 Set일까요?</p>
</blockquote>
<p>DTO가 Request로 넘어올때 Set으로 선언되어 있는 변수는 순서를 보장하지 않아 정렬한 채로 보내도 뒤죽박죽으로 옵니다.<br>
그런 이유로 List로 되어있습니다.</p>
<p>Entity에선 중복을 막기 위해 Set으로 선언했습니다.</p>
<p>Set interface 구현 class는 HashSet으로 되어있어 List로 일괄 변경했습니다.</p>
<p>처음에는 DTO쪽을 List로만 구현하고 나서 확인해보면 순서대로 와서 이제 DB에 제대로 들어가겠지 싶어서 DB에 저장을 몇번 테스트 해보니 몇건은 정상이었지만 역시 뒤죽박죽이었습니다.</p>
<p>원인을 찾고보니 DTO가 Entity로 변화되는 시점에 <code>Set&#x3C;UserRole> userRoles</code>가 HashSet으로 생성되어서 그랬습니다.</p>
<p>Entity를 SortedSet으로 해야하나 싶었지만, JPA가 허용하지 않아서 Set으로 유지했습니다.</p>
<p>결국 LinkedHashSet을 이용해 List 순서를 이어받아야 하는 상황이었습니다.</p>
<p>원하던 상황이었지만 구현된 {Entity}MapperImpl을 살펴보면 Set은 HashSet으로 되어있고 interface를 기준으로 알아서 생성되기 때문에 손을 댈 수가 없었습니다.</p>
<p>저는 정렬을 따로 구현하고 싶지 않았고, MapStruct를 통해 쉽게 바꾸고 싶었습니다.</p>
<h4>해결책은</h4>
<p>UserRoleMapper에 Collection 변환 함수를 만드는 것이 아니고 UserMapper에</p>
<pre><code>LinkedHashSet&#x3C;UserRole> userRoleDTOToEntityLinkedHashSet(Collection&#x3C;UserRoleDTO> userRoleDTOs);
</code></pre>
<p>이런식으로 Collection 변수마다 하나씩 만들어 주게되면 이 함수를 참조하여 for문을 반복합니다.<br>
덕분에 해결할 수 있었습니다.<br>
개발 이란게 가끔은 답답하더라도 이런식으로 방법을 찾게되면 참 기분이 좋아집니다.
문제 없이 돌아가기 위해선 <a href="https://get6.github.io/2020/08/07/mapstruct-guide-second.html">MapStruc 에러 해결 두번째</a>에 나온 방법도 필요합니다.</p>
</div></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"MapStruct 에러 해결 첫번째","date":"2020-08-07","slug":"backend/2020/mapstruct-guide-first/index","content":"\u003cp\u003eMapstruct를 실무에 사용해보면서 겪은 경험을 공유하고자 합니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://mapstruct.org/\"\u003eMapStruct\u003c/a\u003e에 Get Started에는 정말 간단하게 설명되어 있습니다.\nDTO \u0026#x3C;-\u003e Entity를 변경해주는 간단한 library 이지만 확장성은 대단합니다.\u003c/p\u003e\n\u003cp\u003e단순 작업을 build 단계에서 생성해주어 {Entity}Mapper interface를 {Entity}MapperImpl로 만들어줍니다.\u003c/p\u003e\n\u003cp\u003e예를 들어 User Entity에 UserRole이 있다고 가정 해보겠습니다.\u003c/p\u003e\n\u003cp\u003e공식 홈페이지에 더 자세한 설명이 있지만 저희 프로젝트에서 사용하는 모습은 이렇습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Mapper(uses = {UserRoleMapper.class}, unmappedTargetPolicy = ReportingPolicy.ERROR, nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT)\npublic interface UserMapper {\n\n  /**\n   * UserMapper는 연관 Entity Mapper를 사용합니다. users 속한 Mapper 에는 @Mapping(target = \"user\", ignore = true) 설정 되어있습니다.\n   */\n  UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);\n\n  UserDTO toDTO(User user);\n\n  User toEntity(UserDTO userDTO);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e@Mapper annotation에 적힌 부분을 설명드리겠습니다.\u003c/p\u003e\n\u003cp\u003eusers - 다른 Mapper 파일을 참조하려고 할 때, 사용됩니다.\u003c/p\u003e\n\u003cp\u003eusers에 사용된 UserRoleMapper.class입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Mapper(uses = {RoleMapper.class}, unmappedTargetPolicy = ReportingPolicy.ERROR, nullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT)\npublic interface UserRoleMapper {\n\n  UserRoleMapper INSTANCE = Mappers.getMapper(UserRoleMapper.class);\n\n  @Mapping(target = \"user\", ignore = true)\n  UserRoleDTO toDTO(UserRole userRole);\n\n  @Mapping(target = \"user\", ignore = true)\n  UserRole toEntity(UserRoleDTO userRoleDTO);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUserRoleMapper에선 UserRole 안에 있는 user가 변환되는걸 막아야 무한 참조에 빠지지 않습니다.\u003c/p\u003e\n\u003cp\u003e그리고 User가 저장되는 기준으로 Entity변환 후 UserRole을 setUserRole 함수를 이용해 담아 주시면 저장이 되어 아직 문제가 된 상황은 발견하지 못했습니다.\u003cbr\u003e\n아직 발견하지 못한 문제가 있을 수 있습니다.(저도 알고싶어요..)\u003c/p\u003e\n\u003cp\u003eunmappedTargetPolicy - DTO와 Entity에 선언된 변수들이 ignore = true로 되어있지 않은 변수가 변환이 안되는 경우 에러가 나며 Run 되지 않게합니다.\u003c/p\u003e\n\u003cp\u003enullValueMappingStrategy - null인 변수를 초기화 해줍니다. Entity로 변환된 객체에서 .get{OtherEntity}()를 할때 NullpointException을 방지해줍니다.\u003c/p\u003e\n\u003ch4\u003e변경사항 2020.08.12\u003c/h4\u003e\n\u003cp\u003enullValueMappingStrategy = NullValueMappingStrategy.RETURN_DEFAULT)를 사용한 Mapper를 이용해 JPA Repository .save(Entity 구현 객체)함수를 실행했지만 이상한 동작이 생겼습니다.\u003cbr\u003e\n문제는 위 설정을 통해 항상 NullPointException을 방지하고자 객체를 만듭니다.\u003cbr\u003e\n그런 경우 JPA쪽에서 새로운 객체가 생성되고 연관 객체도 Null이 아니여서 Null이 아니지만 텅 빈 객체가 저장될 경우에도 insert를 시도하려고 합니다.\u003cbr\u003e\n이러한 상황때문에 거의 모든 경우에 저 설정을 해제했습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003epublic abstract class UserMapper로 만들어서 beforeMapping이나 afterMapping을 통해 제어도 가능하지만,\u003cbr\u003e\n한 파일에 다른 Entity작업을 몰아주는 것이 옳은 것인가 하는 생각이 들어서 각 Entity마다 Mapper를 만들었습니다.\u003c/p\u003e\n\u003cp\u003e그래서 Domain별 파일구조는\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e{domain}\n\u003cul\u003e\n\u003cli\u003econtroller\u003c/li\u003e\n\u003cli\u003emodel\n\u003cul\u003e\n\u003cli\u003edto\u003c/li\u003e\n\u003cli\u003eentity\u003c/li\u003e\n\u003cli\u003emapper \u0026#x3C;- 여기에 MapStruct 파일이 domain별로 들어가 있습니다.\u003c/li\u003e\n\u003cli\u003evalidator\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003erepository\u003c/li\u003e\n\u003cli\u003eservice\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이런 파일구조로 되어 있습니다.\u003c/p\u003e\n\u003cp\u003eUserMapper.INSTANCE.toEntity, toDTO 함수는 DDD패턴으로 각 Entity에서 수행하도록 함수를 구현해줍니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@Entity\npublic class User {\n\n    ... 다른 부분 생략\n\n    public static User toEntity(UserDTO userDTO) {\n        return UserMapper.INSTANCE.toEntity(userDTO);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDTO \u0026#x3C;-\u003e Entity를 변환해주는 작업을 하게되면 User 객체 (DTO, Entity) 안에는 \u003ccode\u003eList\u0026#x3C;UserRoleDTO\u003e userRoles, Set\u0026#x3C;UserRole\u003e userRoles\u003c/code\u003e로 되어있는 부분까지도 변환을 해줍니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e그러나 Request 요청으로 넘어온 UserDTO 객체 안에 userRoles를 순서대로 넣고싶은 경우 어떻게 할까요?\n왜 DTO는 List interface이고 Entity에는 Set일까요?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eDTO가 Request로 넘어올때 Set으로 선언되어 있는 변수는 순서를 보장하지 않아 정렬한 채로 보내도 뒤죽박죽으로 옵니다.\u003cbr\u003e\n그런 이유로 List로 되어있습니다.\u003c/p\u003e\n\u003cp\u003eEntity에선 중복을 막기 위해 Set으로 선언했습니다.\u003c/p\u003e\n\u003cp\u003eSet interface 구현 class는 HashSet으로 되어있어 List로 일괄 변경했습니다.\u003c/p\u003e\n\u003cp\u003e처음에는 DTO쪽을 List로만 구현하고 나서 확인해보면 순서대로 와서 이제 DB에 제대로 들어가겠지 싶어서 DB에 저장을 몇번 테스트 해보니 몇건은 정상이었지만 역시 뒤죽박죽이었습니다.\u003c/p\u003e\n\u003cp\u003e원인을 찾고보니 DTO가 Entity로 변화되는 시점에 \u003ccode\u003eSet\u0026#x3C;UserRole\u003e userRoles\u003c/code\u003e가 HashSet으로 생성되어서 그랬습니다.\u003c/p\u003e\n\u003cp\u003eEntity를 SortedSet으로 해야하나 싶었지만, JPA가 허용하지 않아서 Set으로 유지했습니다.\u003c/p\u003e\n\u003cp\u003e결국 LinkedHashSet을 이용해 List 순서를 이어받아야 하는 상황이었습니다.\u003c/p\u003e\n\u003cp\u003e원하던 상황이었지만 구현된 {Entity}MapperImpl을 살펴보면 Set은 HashSet으로 되어있고 interface를 기준으로 알아서 생성되기 때문에 손을 댈 수가 없었습니다.\u003c/p\u003e\n\u003cp\u003e저는 정렬을 따로 구현하고 싶지 않았고, MapStruct를 통해 쉽게 바꾸고 싶었습니다.\u003c/p\u003e\n\u003ch4\u003e해결책은\u003c/h4\u003e\n\u003cp\u003eUserRoleMapper에 Collection 변환 함수를 만드는 것이 아니고 UserMapper에\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eLinkedHashSet\u0026#x3C;UserRole\u003e userRoleDTOToEntityLinkedHashSet(Collection\u0026#x3C;UserRoleDTO\u003e userRoleDTOs);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런식으로 Collection 변수마다 하나씩 만들어 주게되면 이 함수를 참조하여 for문을 반복합니다.\u003cbr\u003e\n덕분에 해결할 수 있었습니다.\u003cbr\u003e\n개발 이란게 가끔은 답답하더라도 이런식으로 방법을 찾게되면 참 기분이 좋아집니다.\n문제 없이 돌아가기 위해선 \u003ca href=\"https://get6.github.io/2020/08/07/mapstruct-guide-second.html\"\u003eMapStruc 에러 해결 두번째\u003c/a\u003e에 나온 방법도 필요합니다.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["backend","2020","mapstruct-guide-first","index"]},"buildId":"48cndNy0EEL7Rh6WrBUSX","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>