<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/cf50bc513bb312fb.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf50bc513bb312fb.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf392dd387379326.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf392dd387379326.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-417c86299e0e3115.js" defer=""></script><script src="/_next/static/chunks/pages/_app-3f357b7937ff6115.js" defer=""></script><script src="/_next/static/chunks/358-1fc680902af364db.js" defer=""></script><script src="/_next/static/chunks/675-717e3cc8fb67a947.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-f8930ebaf4ef3376.js" defer=""></script><script src="/_next/static/V9TQmhOimnOCNnuxmYsep/_buildManifest.js" defer=""></script><script src="/_next/static/V9TQmhOimnOCNnuxmYsep/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="absolute w-full pt-3"><div class="container mx-auto flex flex-wrap"><a class="w-2/6 text-lg font-bold" href="/">🌎 Sunhwang&#x27;s blog</a><ul class="flex grow justify-end space-x-10"><li><a class="hover:underline hover:underline-offset-8 " href="/tags">Tags</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/about">About me</a></li></ul></div></nav><main><div class="container mx-auto pt-10"><article class="mb-32"><div class="mx-auto flex max-w-6xl justify-start align-middle"><h1 class="mt-20 mb-6 text-5xl font-bold leading-tight tracking-tighter md:text-left md:text-7xl md:leading-none lg:text-4xl">스프링 시큐리티 구축</h1></div><div class="mb-8 sm:mx-0 md:mb-16"><div class="sm:mx-0"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0"><img alt="Cover Image for 스프링 시큐리티 구축" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="shadow-sm" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Cover Image for 스프링 시큐리티 구축" src="" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="shadow-sm" loading="lazy"/></noscript></span></div></div><div class="mx-auto flex max-w-5xl justify-end"><div class="mb-4 text-sm text-gray-600 underline underline-offset-8"><time dateTime="2020-06-13">2020-06-13</time></div></div><div class="mx-auto max-w-6xl"><article class="markdown-styles_markdown__h_8de"><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Contents</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<p>회사에서 혼자서 spring-security를 이용해 jwt를 발급하는 구조를 만들었다.<br>
물론 고쳐야 할 부분들은 남아있지만 대략적인 개념을 설명하고자 한다.</p>
<p>스크링 시큐리티를 RESTful API로 사용할 계획이라면 jsp같은 페이지가 필요 없을 것이다.</p>
<p>기본 세팅에선 다른 URL을 요청하면 시큐리티가 권한이 없다고 요청을 거부할 것이다.<br>
그러면 로그인을 먼저해서 인증을 받아야한다.<br>
postman을 이용하여 form방식을 이용해 테스트를 했다. email과 password를 post로 날려 요청을 보낼 것이다.<br>
스프링 시큐리티는 기본적으로 /login 요청을 로그인으로 보기 때문에 Controller에 적지 않아도 요청을 알고있다.</p>
<pre><code class="language-java"> @Override
  protected void configure(HttpSecurity http) throws Exception {
      http
          .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN") // 관리자용
            .antMatchers("/user/**").hasRole("USER") // 사용자용
            .antMatchers("/guest/**").permitAll() // 회원가입 이메일 인증 전 임시계정?
          // .antMatchers(HttpMethod.GET,"/", "/home", "/about").permitAll()
            .antMatchers(HttpMethod.POST, "/registry").permitAll()
            .anyRequest().authenticated() // 위를 제외하곤 권한이 있는 사용자는 어디든 접근가능
          .and()
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // no session
          .and()
            .exceptionHandling()
              .authenticationEntryPoint(unauthorizedHandler)
              .accessDeniedHandler(jwtAccessDeniedHandler)
          .and()
            // add jwt filters (1. authentication, 2. authorization)
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            .addFilter(new JwtAuthorizationFilter(authenticationManager(), jwtUtils))
          .rememberMe().disable()
          .formLogin().disable()
          .httpBasic().disable()
          .logout().disable()
          .csrf().disable();
  }
</code></pre>
<p>이런식으로 되어있고 로그인 전 /login 요청은 UsernamePasswordAuthenticationFilter.class를 상속 받아 구현한 filter에 걸리게 된다.</p>
<p>여기서 email과 password로 AbstractAuthenticationToken를 구현한 Custom token을 생성해 provider로 보낸다.</p>
<pre><code class="language-java">return this.getAuthenticationManager().authenticate(authRequest);
</code></pre>
<p>만약 jwt로 만들때 email과 별 정보를 넣지 않는다면 provider와 Custom token을 만들지 않아도 괜찮다.</p>
<p>그러나 나는 email과 id 그리고 혹시 몰라 다른 항목이 추가될 수 있을거 같아 Custom token을 만들었었다.<br>
사실 UsernamePasswordAuthenticationToken애 principal에다가 map이나 다른 자료구조를 이용해 넣어도 돌아가겠지만 정확히 스프링 시큐리티를 이해하지 못했기 때문에 필드를 생성해 명확히 하는게 낫겠다 싶었다.(책을 정독하자..)</p>
<p>AbstractAuthenticationToken를 상속받은 Custom token에 DB에서 조회한 데이터를 넣어준다.</p>
<p>스프링 시큐리티는 기본적으로 DaoAuthenticationProvider를 사용해 여기서 비밀번호 검증까지 해주는데 나는 Controller쪽에서 내가 만든 JwtAuthenticationToken객체를 @AuthenticationPrincipal를 사용해 가져와야 했기때문에 provider를 구현했다.</p>
<p>로그인에 성공하면 jwt로 만든 토큰을 response.header에 실어 돌려주는데</p>
<p>그 뒤로 오는 요청은 BasicAuthenticationFilter을 상속받은 filter에 걸려 jwt를 decode해 사용자를 확인한다.</p>
<p>처음에는 filter 두개 UsernamePasswordAuthenticationFilter, BasicAuthenticationFilter만 있어도 로그인이 되길래 이렇게하면 되나 싶었지만,<br>
비즈니스 로직을 위한 상황이 필요할거 같아 UsernamePasswordAuthenticationToken 말고 원하는 Custom token을 사용하기 위해선 AuthenticationProvider 구현한 provider도 필요했다.</p>
<p>나중에 블로그 좀 더 바꾸고 스프링 시큐리티 모두가 이해할 수 있게 쉽게 시리즈로 작성해 보겠습니다...</p>
<p>이 정도까지 이해할 수 있게 해준 블로거분들과 인터넷 글들께 감사를 드립니다아아</p>
</body>
</html>
</article></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"스프링 시큐리티 구축","date":"2020-06-13","slug":"backend/2020/spring-security/index","content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003ctitle\u003eContents\u003c/title\u003e\n\u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e회사에서 혼자서 spring-security를 이용해 jwt를 발급하는 구조를 만들었다.\u003cbr\u003e\n물론 고쳐야 할 부분들은 남아있지만 대략적인 개념을 설명하고자 한다.\u003c/p\u003e\n\u003cp\u003e스크링 시큐리티를 RESTful API로 사용할 계획이라면 jsp같은 페이지가 필요 없을 것이다.\u003c/p\u003e\n\u003cp\u003e기본 세팅에선 다른 URL을 요청하면 시큐리티가 권한이 없다고 요청을 거부할 것이다.\u003cbr\u003e\n그러면 로그인을 먼저해서 인증을 받아야한다.\u003cbr\u003e\npostman을 이용하여 form방식을 이용해 테스트를 했다. email과 password를 post로 날려 요청을 보낼 것이다.\u003cbr\u003e\n스프링 시큐리티는 기본적으로 /login 요청을 로그인으로 보기 때문에 Controller에 적지 않아도 요청을 알고있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e @Override\n  protected void configure(HttpSecurity http) throws Exception {\n      http\n          .authorizeRequests()\n            .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") // 관리자용\n            .antMatchers(\"/user/**\").hasRole(\"USER\") // 사용자용\n            .antMatchers(\"/guest/**\").permitAll() // 회원가입 이메일 인증 전 임시계정?\n          // .antMatchers(HttpMethod.GET,\"/\", \"/home\", \"/about\").permitAll()\n            .antMatchers(HttpMethod.POST, \"/registry\").permitAll()\n            .anyRequest().authenticated() // 위를 제외하곤 권한이 있는 사용자는 어디든 접근가능\n          .and()\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // no session\n          .and()\n            .exceptionHandling()\n              .authenticationEntryPoint(unauthorizedHandler)\n              .accessDeniedHandler(jwtAccessDeniedHandler)\n          .and()\n            // add jwt filters (1. authentication, 2. authorization)\n            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)\n            .addFilter(new JwtAuthorizationFilter(authenticationManager(), jwtUtils))\n          .rememberMe().disable()\n          .formLogin().disable()\n          .httpBasic().disable()\n          .logout().disable()\n          .csrf().disable();\n  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런식으로 되어있고 로그인 전 /login 요청은 UsernamePasswordAuthenticationFilter.class를 상속 받아 구현한 filter에 걸리게 된다.\u003c/p\u003e\n\u003cp\u003e여기서 email과 password로 AbstractAuthenticationToken를 구현한 Custom token을 생성해 provider로 보낸다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003ereturn this.getAuthenticationManager().authenticate(authRequest);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 jwt로 만들때 email과 별 정보를 넣지 않는다면 provider와 Custom token을 만들지 않아도 괜찮다.\u003c/p\u003e\n\u003cp\u003e그러나 나는 email과 id 그리고 혹시 몰라 다른 항목이 추가될 수 있을거 같아 Custom token을 만들었었다.\u003cbr\u003e\n사실 UsernamePasswordAuthenticationToken애 principal에다가 map이나 다른 자료구조를 이용해 넣어도 돌아가겠지만 정확히 스프링 시큐리티를 이해하지 못했기 때문에 필드를 생성해 명확히 하는게 낫겠다 싶었다.(책을 정독하자..)\u003c/p\u003e\n\u003cp\u003eAbstractAuthenticationToken를 상속받은 Custom token에 DB에서 조회한 데이터를 넣어준다.\u003c/p\u003e\n\u003cp\u003e스프링 시큐리티는 기본적으로 DaoAuthenticationProvider를 사용해 여기서 비밀번호 검증까지 해주는데 나는 Controller쪽에서 내가 만든 JwtAuthenticationToken객체를 @AuthenticationPrincipal를 사용해 가져와야 했기때문에 provider를 구현했다.\u003c/p\u003e\n\u003cp\u003e로그인에 성공하면 jwt로 만든 토큰을 response.header에 실어 돌려주는데\u003c/p\u003e\n\u003cp\u003e그 뒤로 오는 요청은 BasicAuthenticationFilter을 상속받은 filter에 걸려 jwt를 decode해 사용자를 확인한다.\u003c/p\u003e\n\u003cp\u003e처음에는 filter 두개 UsernamePasswordAuthenticationFilter, BasicAuthenticationFilter만 있어도 로그인이 되길래 이렇게하면 되나 싶었지만,\u003cbr\u003e\n비즈니스 로직을 위한 상황이 필요할거 같아 UsernamePasswordAuthenticationToken 말고 원하는 Custom token을 사용하기 위해선 AuthenticationProvider 구현한 provider도 필요했다.\u003c/p\u003e\n\u003cp\u003e나중에 블로그 좀 더 바꾸고 스프링 시큐리티 모두가 이해할 수 있게 쉽게 시리즈로 작성해 보겠습니다...\u003c/p\u003e\n\u003cp\u003e이 정도까지 이해할 수 있게 해준 블로거분들과 인터넷 글들께 감사를 드립니다아아\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["backend","2020","spring-security","index"]},"buildId":"V9TQmhOimnOCNnuxmYsep","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>