<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><meta charSet="utf-8"/><link rel="preload" href="/_next/static/css/b8016db199e3d50e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8016db199e3d50e.css" data-n-g=""/><link rel="preload" href="/_next/static/css/cf121497002c184d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/cf121497002c184d.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-591bb7ec51acdc0d.js" defer=""></script><script src="/_next/static/chunks/pages/_app-4db42315f1cad4cf.js" defer=""></script><script src="/_next/static/chunks/675-717e3cc8fb67a947.js" defer=""></script><script src="/_next/static/chunks/194-b74e21e59d8a75e2.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5B...slug%5D-f82e37ce8fef3000.js" defer=""></script><script src="/_next/static/gvvvKtR0vBN_FJ3fanf7F/_buildManifest.js" defer=""></script><script src="/_next/static/gvvvKtR0vBN_FJ3fanf7F/_ssgManifest.js" defer=""></script></head><body><div id="__next"><nav class="absolute flex w-full justify-between py-4"><div class="ml-20 mr-40 flex-none"><a class="text-lg font-bold" href="/">🌎 Sunhwang&#x27;s blog</a></div><ul class="flex flex-auto flex-row justify-evenly"><li><a class="hover:underline hover:underline-offset-8 " href="/categories">Categories</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/tags">Tags</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/books">Books</a></li><li><a class="hover:underline hover:underline-offset-8 " href="/about">About me</a></li></ul></nav><main><div class="container mx-auto px-5"><article class="mb-32"><h1 class="mb-12 text-center text-5xl font-bold leading-tight tracking-tighter md:text-left md:text-7xl md:leading-none lg:text-8xl">JPA 정리</h1><div class="mb-8 sm:mx-0 md:mb-16"><div class="sm:mx-0"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0"><img alt="Cover Image for JPA 정리" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="intrinsic" class="shadow-sm" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"/><noscript><img alt="Cover Image for JPA 정리" src="" decoding="async" data-nimg="intrinsic" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%" class="shadow-sm" loading="lazy"/></noscript></span></div></div><div class="mx-auto max-w-2xl"><div class="mb-6 text-lg"><time dateTime="2020-06-08">June	8, 2020</time></div></div><div class="mx-auto max-w-2xl"><div class="markdown-styles_markdown__h_8de"><p>자바 ORM 표준 JPA 프로그래밍을 읽으면서 정리할 예정입니다.</p>
<h3>엔티티 매니저 팩토리</h3>
<p>앤티티 매니저를 만드는 공장이다. EntityManagerFactory는 객체 생성 비용이 크기 때문에 애플리케이션 전체에서 공유하도록 설계되어 있다.<br>
여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다.
이때, 커넥션풀도 만든다.</p>
<h3>엔티티 매니저</h3>
<p>엔티티를 저장, 수정, 삭제, 조회 등을 처리한다. 엔티티를 저장하는 가상의 데이터베이스로 생각해도 된다.<br>
여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.<br>
연결이 필요한 시점에 커넥션을 얻는다. ex) 트랙젝션을 시작할 때 획득</p>
<h3>영속성 컨텍스트</h3>
<p>해석하면 엔티티를 영구 저장하는 환경이라는 뜻<br>
em.persiste(account); 메소드는 엔티티 매니저를 사용해서 계정 엔티티를 영속성 컨텍스트에 저장한다.
여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수 있다.</p>
<ul>
<li>엔티티의 생명주기
<ol>
<li>비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태</li>
<li>영속(managed): 영속성 컨텍스트에 저장된 상태</li>
<li>준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태</li>
<li>삭제(removed): 삭제된 상태</li>
</ol>
</li>
</ul>
<h3>플러시</h3>
<p>flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.</p>
<ol>
<li>직접 호출</li>
<li>트랜잭션 커밋 시 플러시 자동 호출</li>
<li>JPQL 쿼리 실행 시 플러시 자동 호출</li>
</ol>
<hr>
<h2>매핑 어노테이션</h2>
<ul>
<li>객체와 테이블 매핑: @Entity, @Table</li>
<li>기본 키 매핑: @Id</li>
<li>필드와 컬럼 매핑: @Column</li>
<li>연관관계 매핑: @ManyToOne, @JoinColumn ... etc</li>
</ul>
<p>@Entity</p>
<p>JPA를 사용해 테이블과 매핑할 클래스에 필수로 붙여야 하고, annotation을 클래스 위에 선언해야 한다.</p>
<p>주의사항</p>
<ol>
<li>인자를 받는 생성자를 구현한 경우 기본 생성자는 필수로 생성해야한다.</li>
<li>final, enum, interface, inner 클래스에는 사용할 수 없다.</li>
<li>저장할 필드에 final이 있으면 안 된다.</li>
</ol>
<p>엔티티 매니저가 이 Entity 클래스들을 관리한다.</p>
<p>@Table</p>
<p>@Entity와 마찬가지로 클래스 위에 선언하며 매핑할 테이블명을 넣어주면 된다.</p>
<p>@Id</p>
<p>테이블에서 사용할 PK를 지정하는 annotatin이다. 필드 또는 getter에 지정할 수 있다.<br>
엔티티 클래스를 생성할 때 필수적으로 넣어줘야 한다.</p>
</div></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"JPA 정리","date":"2020-06-08","slug":"backend/2020/java-jpa/index","content":"\u003cp\u003e자바 ORM 표준 JPA 프로그래밍을 읽으면서 정리할 예정입니다.\u003c/p\u003e\n\u003ch3\u003e엔티티 매니저 팩토리\u003c/h3\u003e\n\u003cp\u003e앤티티 매니저를 만드는 공장이다. EntityManagerFactory는 객체 생성 비용이 크기 때문에 애플리케이션 전체에서 공유하도록 설계되어 있다.\u003cbr\u003e\n여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다.\n이때, 커넥션풀도 만든다.\u003c/p\u003e\n\u003ch3\u003e엔티티 매니저\u003c/h3\u003e\n\u003cp\u003e엔티티를 저장, 수정, 삭제, 조회 등을 처리한다. 엔티티를 저장하는 가상의 데이터베이스로 생각해도 된다.\u003cbr\u003e\n여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.\u003cbr\u003e\n연결이 필요한 시점에 커넥션을 얻는다. ex) 트랙젝션을 시작할 때 획득\u003c/p\u003e\n\u003ch3\u003e영속성 컨텍스트\u003c/h3\u003e\n\u003cp\u003e해석하면 엔티티를 영구 저장하는 환경이라는 뜻\u003cbr\u003e\nem.persiste(account); 메소드는 엔티티 매니저를 사용해서 계정 엔티티를 영속성 컨텍스트에 저장한다.\n여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수 있다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e엔티티의 생명주기\n\u003col\u003e\n\u003cli\u003e비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태\u003c/li\u003e\n\u003cli\u003e영속(managed): 영속성 컨텍스트에 저장된 상태\u003c/li\u003e\n\u003cli\u003e준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태\u003c/li\u003e\n\u003cli\u003e삭제(removed): 삭제된 상태\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e플러시\u003c/h3\u003e\n\u003cp\u003eflush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e직접 호출\u003c/li\u003e\n\u003cli\u003e트랜잭션 커밋 시 플러시 자동 호출\u003c/li\u003e\n\u003cli\u003eJPQL 쿼리 실행 시 플러시 자동 호출\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2\u003e매핑 어노테이션\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e객체와 테이블 매핑: @Entity, @Table\u003c/li\u003e\n\u003cli\u003e기본 키 매핑: @Id\u003c/li\u003e\n\u003cli\u003e필드와 컬럼 매핑: @Column\u003c/li\u003e\n\u003cli\u003e연관관계 매핑: @ManyToOne, @JoinColumn ... etc\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e@Entity\u003c/p\u003e\n\u003cp\u003eJPA를 사용해 테이블과 매핑할 클래스에 필수로 붙여야 하고, annotation을 클래스 위에 선언해야 한다.\u003c/p\u003e\n\u003cp\u003e주의사항\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e인자를 받는 생성자를 구현한 경우 기본 생성자는 필수로 생성해야한다.\u003c/li\u003e\n\u003cli\u003efinal, enum, interface, inner 클래스에는 사용할 수 없다.\u003c/li\u003e\n\u003cli\u003e저장할 필드에 final이 있으면 안 된다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e엔티티 매니저가 이 Entity 클래스들을 관리한다.\u003c/p\u003e\n\u003cp\u003e@Table\u003c/p\u003e\n\u003cp\u003e@Entity와 마찬가지로 클래스 위에 선언하며 매핑할 테이블명을 넣어주면 된다.\u003c/p\u003e\n\u003cp\u003e@Id\u003c/p\u003e\n\u003cp\u003e테이블에서 사용할 PK를 지정하는 annotatin이다. 필드 또는 getter에 지정할 수 있다.\u003cbr\u003e\n엔티티 클래스를 생성할 때 필수적으로 넣어줘야 한다.\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/posts/[...slug]","query":{"slug":["backend","2020","java-jpa","index"]},"buildId":"gvvvKtR0vBN_FJ3fanf7F","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>