{"pageProps":{"post":{"title":"GoF(Gang of Four) Design Patterns 정리","date":"2021-01-17","slug":"methodology/2021/gof-design-patterns/index","content":"<p>정보처리기사책을 공부하다 보면 나오는 GoF 디자인 패턴이 나옵니다.</p>\n<p>예제가 있으면 이해가 쉬울거 같아 정리를 해봅니다.</p>\n<p>저는 Dart언어를 좋아해서 구글링을 해보니 이미 누군가가 정리해 놓은 글이 있어 인용합니다. <a href=\"https://scottt2.github.io/design-patterns-in-dart/\">Dart로 구현한 Degisn Patterns</a></p>\n<h1>생성(Creational) 패턴</h1>\n<ul>\n<li>객체를 생성하는 데 사용되는 패턴이다.</li>\n<li>클래스 정의와 객체 생성 방식을 구조화, 캡슐화한 방법을 제사한다.</li>\n<li>객체를 생성하거나 수정되어도 프로그램 구조에 영향을 적게 받도록 한다.</li>\n<li>캡슐화하여 부작용을 최소화한다.</li>\n</ul>\n<h2>종류</h2>\n<p>5개</p>\n<h3>Abstract Facotry</h3>\n<ul>\n<li>추상 팩토리 패턴은 구체적인 클래스를 지정하지 않고 공통된 주제를 가진 개별 팩토리 그룹을 캡슐화하는 방법을 제공한다.</li>\n</ul>\n<pre><code>// '마실 수 있는' 추상형태를 가진 추상 클래스 정의\nabstract class Drinkable {\n  void pour(); // '붓다'라는 함수를 갖는다\n}\n\n// Beer 객체를 정의\n// Drinkable 추상 클래스를 구현해 추상 팩토리에서 활용할 수 있는 객체로 만듦\nclass Beer implements Drinkable {\n  // 함수를 구현\n  void pour() {\n    print(\"Pouring a delicious beer!\");\n  }\n}\n\n// Coffee 객체를 정의\n// Beer와 마찬가지로 Drinkable에는 두 종류의 구현 객체가 존재\nclass Coffee implements Drinkable {\n  void pour() {\n    print(\"Pouring a refreshing coffee!\");\n  }\n}\n\n// 추상 팩토리 객체를 정의\nabstract class DrinkFactory {\n  // Drinkable 객체를 return 하는 함수를 갖는다\n  Drinkable createDrink();\n}\n\n// Pub 객체를 정의\n// DrinkFactory 추상 클래스를 구현\nclass Pub implements DrinkFactory {\n  // Beer를 만들어 주는 함수를 구현\n  Drinkable createDrink() {\n    return Beer();\n  }\n}\n\n// CoffeeShop 객체를 정의\n// Pub과 마찬가지로 DrinkFactory에는 두 종류의 구현 객체가 존재\nclass CoffeeShop implements DrinkFactory {\n  Drinkable createDrink() {\n    return Coffee();\n  }\n}\n\nvoid main() {\n  // 기분을 설정\n  var mood = \"sleepy\";\n  DrinkFactory destination;\n\n  // 기분에 따라 생성되는 객체가 달라짐\n  switch (mood) {\n    case \"sleepy\":\n      destination = CoffeeShop();\n      break;\n    case \"done\":\n      destination = Pub();\n      break;\n    default:\n      print(\"I only have two moods...\");\n  }\n\n  // 음료를 생성\n  var myBeverage = destination.createDrink();\n  // 부으면 음료에 따라 호출되는 내용이 달라짐\n  myBeverage.pour();\n}\n</code></pre>\n<h3>Factory Method</h3>\n<ul>\n<li>팩토리 메서드 패턴은 생성 될 객체의 정확한 클래스를 지정하지 않고도 팩토리 메소드를 사용하여 개체를 만드는 문제를 처리하는 생성 패턴입니다.</li>\n</ul>\n<pre><code>class Volume {\n  // 상수 변수 두개 선언\n  final int quantity;\n  final String unit;\n\n  // 생성자 지정\n  Volume(this.quantity, this.unit);\n  String toString() => \"$quantity $unit\";\n}\n\n// 추상 클래스 정의\nabstract class Vessel {\n  Volume volume;\n  String liquid;\n}\n\n// Vessel을 상속받은 Bucket 정의\nclass Bucket extends Vessel {\n  final Volume volume;\n\n  // 생성자에서 받은 인자를 Volumn 생성자에 넘겨줌 값을 내부 변수 volume에 대입\n  Bucket(int q, String u) : volume = Volume(q, u);\n  // toString 함수 정의\n  String toString() => \"a $volume bucket full of $liquid\";\n}\n\nclass Cup extends Vessel {\n  final Volume volume;\n\n  Cup(int q, String u) : volume = Volume(q, u);\n  String toString() => \"a $volume cup full of $liquid\";\n}\n\n// '피로'라는 enum 정의\nenum Tiredness {\n  // 휴식, 졸림, 겨우 살아있음, 아이가 있다(말 못할 고통??)\n  rested,\n  sleepy,\n  barelyAlive,\n  hasChildren\n}\n\n// 커피 용기 공장 함수 정의\nclass CoffeeVesselFactory {\n  // 전역 함수 정의\n  static Vessel vesselFor(Tiredness howTired) {\n    Vessel vessel;\n    // 얼마나 피곤하지에 따라서 용기의 양이 달라짐\n    switch (howTired) {\n      case Tiredness.rested:\n        vessel = Cup(100, \"milliliter\");\n        break;\n      case Tiredness.sleepy:\n      case Tiredness.barelyAlive:\n        vessel = Cup(500, \"milliliter\");\n        break;\n      case Tiredness.hasChildren:\n        vessel = Bucket(5, \"liter\");\n        break;\n      default:\n        vessel = Cup(200, \"milliliter\");\n        break;\n    }\n    // 액체는 모두 다 커피\n    vessel.liquid = \"coffee\";\n    return vessel;\n  }\n}\n\nvoid main() {\n  var sleepyVessel = CoffeeVesselFactory.vesselFor(Tiredness.sleepy);\n  var kidVessel = CoffeeVesselFactory.vesselFor(Tiredness.hasChildren);\n\n  // A sleepy person would like a 500 milliliter cup full of coffee.\n  print(\"A sleepy person would like $sleepyVessel.\");\n  // A person with children NEEDS a 5 liter bucket full of coffee.\n  print(\"A person with children NEEDS $kidVessel.\");\n}\n\n</code></pre>\n<h3>Builder</h3>\n<ul>\n<li>Builder 디자인 패턴의 목적은 복잡한 객체의 구성과 표현을 분리하는 것입니다.</li>\n<li>이런식으로 같은 생성 방식으로 다른 객체들을 만들 수 있습니다.</li>\n</ul>\n<pre><code>class PizzaBuilder {\n  // 빵 껍질\n  String _crust;\n  // 지름\n  int _diameter;\n  // 구성들\n  Set&#x3C;String> _toppings;\n\n  PizzaBuilder(this._diameter);\n\n  // getter\n  String get crust => _crust;\n  // setter\n  set crust(String newCrust) {\n    _crust = newCrust;\n  }\n\n  int get diameter => _diameter;\n  set diameter(int newDiameter) {\n    _diameter = newDiameter;\n  }\n\n  Set&#x3C;String> get toppings => _toppings;\n  set toppings(Set&#x3C;String> newToppings) {\n    _toppings = newToppings;\n    _ensureCheese();\n  }\n\n  // 치즈 추가\n  void _ensureCheese() {\n    _toppings.add(\"cheese\");\n  }\n\n  Pizza build() {\n    return Pizza(this);\n  }\n}\n\nclass Pizza {\n  String _crust;\n  int _diameter;\n  Set&#x3C;String> _toppings;\n\n  Pizza(PizzaBuilder builder) {\n    _crust = builder.crust;\n    _diameter = builder.diameter;\n    _toppings = builder.toppings;\n  }\n\n  String get crust => _crust;\n  int get diameter => _diameter;\n  String get toppings => _stringifiedToppings();\n  // 토핑 목록을 \", \"으로 연결된 문자열로 변환\n  String _stringifiedToppings() {\n    var stringToppings = _toppings.join(\", \");\n    var lastComma = stringToppings.lastIndexOf(\",\");\n    var replacement =\n        \",\".allMatches(stringToppings).length > 1 ? \", and\" : \" and\";\n\n    return stringToppings.replaceRange(lastComma, lastComma + 1, replacement);\n  }\n\n  @override\n  String toString() {\n    return \"A delicious $_diameter\\\" pizza with $_crust crust covered in $toppings\";\n  }\n}\n\nvoid main() {\n  /**\n   * * pizzaBuilder에 속성들을 집어넣은 후\n   * * Pizza 객체 생성자에 pizzaBuilder를 넣어 생성하면 완성된 피자가 만들어진다.\n   */\n  // Create a handy PizzaBuilder with an 8\" diameter.\n  var pizzaBuilder = PizzaBuilder(8);\n\n  // Add some attributes to the builder.\n  pizzaBuilder.crust = \"deep dish\";\n  pizzaBuilder.toppings = Set.from([\"pepperoni\"]);\n\n  // Let's make a pizza!\n  var plainPizza = Pizza(pizzaBuilder);\n  print(\"Behold! $plainPizza\");\n  assert(plainPizza.toString() ==\n      \"A delicious 8\\\" pizza with deep dish crust covered in pepperoni and cheese\");\n\n  // Now to adjust some things for the next pizza...\n  pizzaBuilder.crust = \"gold plated\";\n  pizzaBuilder.diameter = 72;\n  pizzaBuilder.toppings = Set.from([\"anchovies\", \"caviar\", \"diamonds\"]);\n\n  // The beauty of the build is you can quickly iterate and produce instances of a class.\n  // For example, we have an early employee of the latest unicorn in line. So much disposable income!\n  // Also note, we use the .build() function of the builder this time.\n  var luxuriousPizza = pizzaBuilder.build();\n  print(\"Wow! $luxuriousPizza? Somone is rich!\");\n  assert(luxuriousPizza.toString() ==\n      \"A delicious 72\\\" pizza with gold plated crust covered in anchovies, caviar, diamonds, and cheese\");\n}\n\n</code></pre>\n<h3>Prototype</h3>\n<ul>\n<li>프로토타입 방식은 새 객체를 생성하기 위해 복제되는 원형 객체에 의해 결정됩니다.</li>\n<li>이 패턴은 이럴 때 사용됩니다.\n<ul>\n<li>애플리케이션에서 팩토리 메서드 방식이 하는 것처럼 객체 생성자의 하위 클래스를 피할 때</li>\n<li>애플리케이션에서 기본 방식으로(예 new 키워드 사용) 새 객체 생성이 엄청나게 많은 비용이 발생하는 경우를 피하기 위해</li>\n</ul>\n</li>\n<li>이 방식을 구현하려면, 순수한 가상 clone() 함수를 정의한 기본 추상 클래스를 선언하세요. 추상 클래스에서 파생된 \"다형 생성자\" 기능이 필요한 클래스는 clone() 함수를 구현해야합니다.</li>\n</ul>\n<pre><code>abstract class Shape {\n  int x;\n  int y;\n  Shape clone();\n}\n\nclass Rectangle implements Shape {\n  int height;\n  int width;\n  int x;\n  int y;\n\n  int _hashCode;\n  bool isClone = false;\n  String get cloneStatus => isClone ? \"is a clone\" : \"is an original gangster\";\n\n  Rectangle(this.height, this.width, this.x, this.y);\n\n  Rectangle.fromSource(Rectangle source) {\n    height = source.height;\n    width = source.width;\n    x = source.x;\n    y = source.y;\n    _hashCode = source.hashCode;\n    isClone = true;\n  }\n\n  @override\n  Rectangle clone() {\n    return Rectangle.fromSource(this);\n  }\n\n  @override\n  int get hashCode {\n    if (_hashCode != null) return _hashCode;\n    _hashCode = DateTime.now().microsecondsSinceEpoch;\n    return _hashCode;\n  }\n\n  @override\n  bool operator ==(dynamic other) {\n    if (other is Rectangle) return false;\n    Rectangle rect = other;\n    return rect.isClone &#x26;&#x26; rect.hashCode == hashCode;\n  }\n}\n\nvoid main() {\n  var ogRect = Rectangle(0, 0, 100, 100);\n  var cloneRect = ogRect.clone();\n  var someOtherRect = Rectangle(0, 0, 100, 100);\n\n  print(\"ogRect ${ogRect.cloneStatus}.\");\n  print(\"cloneRect ${cloneRect.cloneStatus}.\");\n  print(\"someOtherRect ${someOtherRect.cloneStatus}.\");\n\n  String cloneIsClonse =\n      ogRect == cloneRect ? \"is a clone of\" : \"is not a clone of\";\n  print(\"\\r\\ncloneRect $cloneIsClonse ogRect\");\n\n  String someRectIsClone =\n      ogRect == someOtherRect ? \"is a clone of\" : \"is not a clone of\";\n  print(\"someOtherRect $someRectIsClone ogRect\");\n}\n</code></pre>\n<h3>Singleton</h3>\n<ul>\n<li>싱글톤 패턴은 클래스의 구현을 단 하나만 생성되기로 제한한 방식입니다. 시스템 내에서 한 객체만 필요한 경우 유용합니다.\n<ul>\n<li>Abstract factory, Builder, Prototype 패턴은 구현에 singleton으로 사용할 수 있습니다.</li>\n<li>Facade 객체는 종종 하나의 facade 객체만을 필요로 하기 때문에 singleton입니다.</li>\n<li>State 객체는 종종 singleton입니다.</li>\n</ul>\n</li>\n<li>싱글톤 패턴은 전역변수로 자주 사용됩니다.</li>\n</ul>\n<pre><code>class Me {\n  static final Me _singleton = new Me._internal();\n  static final String _name = \"Typer\";\n\n  // 생성자 함수\n  factory Me() {\n    return _singleton;\n  }\n\n  static String get name => _name;\n\n  @override\n  String toString() => \"Hello, my name is $name\";\n\n  // private 생성자, 아무 이름이나 지정 가능\n  Me._internal();\n}\n\nvoid main() {\n  var tyler = Me();\n  var anotherTyler = Me();\n\n  print(tyler);\n  print(anotherTyler);\n\n  var samenessCheck = identical(tyler, anotherTyler)\n      ? \"We are both the same ${Me.name}\"\n      : \"We are NOT the same. I mean, just look at us.\";\n  print(samenessCheck);\n}\n</code></pre>\n<h1>구조(Structural) 패턴</h1>\n<ul>\n<li>여러 개의 객체를 모아 구조화시키는 패턴이다.</li>\n<li>여러 개의 객체를 접근할 수 있는 인터페이스를 제공한다.</li>\n<li>여러 개의 객체를 모아 새로운 기능을 제공하게 한다.</li>\n</ul>\n<h2>종류</h2>\n<p>7개</p>\n<h3>Adapter</h3>\n<ul>\n<li>USB 장치, HDMI처럼 호환되지 않는 두 인터페이스를 이어주는 역할</li>\n</ul>\n<pre><code>const adapteeMessage = 'Adaptee#method was called';\n\nclass Adaptee {\n  String method() {\n    print('Adaptee#method is being called');\n\n    return adapteeMessage;\n  }\n}\n\n// 추상 클래스\nabstract class Target {\n  String call();\n}\n\nclass Adapter implements Target {\n  @override\n  String call() {\n    // Adapter 함수 안에서 Adaptee 클래스 인스턴스 생성\n    var adaptee = Adaptee();\n    print('Adapter#call is being called');\n    return adaptee.method();\n  }\n}\n\nvoid main(List&#x3C;String> arguments) {\n  // Adapter 클래스 인스턴스 생성\n  var adapter = Adapter();\n  // call 함수 결과 반환\n  var result = adapter.call();\n  // 결과와 메세지가 같은지 비교\n  assert(result == adapteeMessage);\n}\n</code></pre>\n<h3>Bridge</h3>\n<ul>\n<li>두 개가 독립적으로 다를 수 있도록 구현에서 추상화를 분리하는 것.</li>\n<li>브릿지 패턴은 캡슐화, aggregation을 사용하고 책임을 다른 클래스로 구분하기 위해 상속을 사용할 수 있습니다.</li>\n<li>브릿지는 어댑터와 자주 혼동됩니다.</li>\n</ul>\n<h3>Composite</h3>\n<h3>Decorator</h3>\n<h3>Facade</h3>\n<h3>Flyweight</h3>\n<h3>Proxy</h3>\n<h1>행위(Behavioral) 패턴</h1>\n<ul>\n<li>객체의 구체적인 알고리즘을 정의하는 패턴이다.</li>\n<li>큰 작업을 여러 개의 객체로 분리한 방법을 제공한다.</li>\n<li>반복적으로 사용하는 객체들의 상호 작용을 패턴화한 것으로 객체의 행위를 조직화, 관리, 연합하는데 사용되는 패턴이다.</li>\n<li>객체 사이의 결합도를 최소화한다.</li>\n<li>알고리즘 수행에 주로 사용된다.</li>\n</ul>\n<h2>종류</h2>\n<p>10개</p>\n<h3>Chain of Responsibility</h3>\n<h3>Command</h3>\n<h3>Interpreter</h3>\n<h3>Iterator</h3>\n<h3>Mediator</h3>\n<h3>Memento</h3>\n<h3>Observer</h3>\n<h3>State</h3>\n<h3>Strategy</h3>\n<h3>Template Method</h3>\n<h3>Visitor</h3>\n"}},"__N_SSG":true}