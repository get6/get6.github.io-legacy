{"pageProps":{"post":{"title":"JPA 정리","date":"2020-06-08","slug":"backend/2020/java-jpa/index","content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Contents</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n</head>\n<body>\n<p>자바 ORM 표준 JPA 프로그래밍을 읽으면서 정리할 예정입니다.</p>\n<h3 id=\"엔티티-매니저-팩토리\">엔티티 매니저 팩토리</h3>\n<p>앤티티 매니저를 만드는 공장이다. EntityManagerFactory는 객체 생성 비용이 크기 때문에 애플리케이션 전체에서 공유하도록 설계되어 있다.<br>\n여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다.\n이때, 커넥션풀도 만든다.</p>\n<h3 id=\"엔티티-매니저\">엔티티 매니저</h3>\n<p>엔티티를 저장, 수정, 삭제, 조회 등을 처리한다. 엔티티를 저장하는 가상의 데이터베이스로 생각해도 된다.<br>\n여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.<br>\n연결이 필요한 시점에 커넥션을 얻는다. ex) 트랙젝션을 시작할 때 획득</p>\n<h3 id=\"영속성-컨텍스트\">영속성 컨텍스트</h3>\n<p>해석하면 엔티티를 영구 저장하는 환경이라는 뜻<br>\nem.persiste(account); 메소드는 엔티티 매니저를 사용해서 계정 엔티티를 영속성 컨텍스트에 저장한다.\n여러 엔티티 매니저가 같은 영속성 컨텍스트에 접근할 수 있다.</p>\n<ul>\n<li>엔티티의 생명주기\n<ol>\n<li>비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 상태</li>\n<li>영속(managed): 영속성 컨텍스트에 저장된 상태</li>\n<li>준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태</li>\n<li>삭제(removed): 삭제된 상태</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"플러시\">플러시</h3>\n<p>flush()는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.</p>\n<ol>\n<li>직접 호출</li>\n<li>트랜잭션 커밋 시 플러시 자동 호출</li>\n<li>JPQL 쿼리 실행 시 플러시 자동 호출</li>\n</ol>\n<hr>\n<h2 id=\"매핑-어노테이션\">매핑 어노테이션</h2>\n<ul>\n<li>객체와 테이블 매핑: @Entity, @Table</li>\n<li>기본 키 매핑: @Id</li>\n<li>필드와 컬럼 매핑: @Column</li>\n<li>연관관계 매핑: @ManyToOne, @JoinColumn ... etc</li>\n</ul>\n<p>@Entity</p>\n<p>JPA를 사용해 테이블과 매핑할 클래스에 필수로 붙여야 하고, annotation을 클래스 위에 선언해야 한다.</p>\n<p>주의사항</p>\n<ol>\n<li>인자를 받는 생성자를 구현한 경우 기본 생성자는 필수로 생성해야한다.</li>\n<li>final, enum, interface, inner 클래스에는 사용할 수 없다.</li>\n<li>저장할 필드에 final이 있으면 안 된다.</li>\n</ol>\n<p>엔티티 매니저가 이 Entity 클래스들을 관리한다.</p>\n<p>@Table</p>\n<p>@Entity와 마찬가지로 클래스 위에 선언하며 매핑할 테이블명을 넣어주면 된다.</p>\n<p>@Id</p>\n<p>테이블에서 사용할 PK를 지정하는 annotatin이다. 필드 또는 getter에 지정할 수 있다.<br>\n엔티티 클래스를 생성할 때 필수적으로 넣어줘야 한다.</p>\n</body>\n</html>\n"}},"__N_SSG":true}