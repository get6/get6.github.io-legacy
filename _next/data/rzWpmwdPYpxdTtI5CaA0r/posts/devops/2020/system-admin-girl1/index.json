{"pageProps":{"post":{"title":"만화로 배우는 리눅스 시스템 관리 1권","date":"2021-03-14","slug":"devops/2020/system-admin-girl1/index","content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<title>Contents</title>\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n</head>\n<body>\n<p>전에 읽었던 책이지만, 설명을 쉽게 풀어서 리눅스 입문하기 좋은 책이라고 생각되어 찾아봤습니다.<br>\n서울전자도서관에선 계약 문제인지 검색이 더 이상 되지 않았습니다.<br>\n다행히 경기도사이버도서관에서 1,2권이 있어 대출 후 책을 읽어가며 요약을 해보려고 합니다.</p>\n<h2 id=\"명령어--셸-스크립트-입문\">명령어 &#x26; 셸 스크립트 입문</h2>\n<h3 id=\"1화-다른-컴퓨터를-리모트로-조작하고-싶어ssh\">1화 다른 컴퓨터를 리모트로 조작하고 싶어(SSH)</h3>\n<p><code>ssh</code>(Secure SHell) - 다른 PC에서 동작하는 프로그램을 자기 PC 화면에 표시해서 조작할 수 있게 하는 명령어.</p>\n<p>터미널을 실행해서 ssh 명령어 뒤에 로그인할 사용자명, @, 접속할 로그인 PC 주소를 입력합니다.</p>\n<pre><code class=\"language-bash\">ssh {로그인할 사용자명}@{접속할 로그인 PC 주소}\n</code></pre>\n<p>X를 활용해 SSH 사용<br>\n<strong>ssh 옵션</strong>(X를 사용할 때, X는 리눅스에서 화면 표시와 입력을 담당하는 구조)<br>\n-Y : X 전송 지정<br>\n-C : 통신 내용을 압축(응답 속도를 좋게함)</p>\n<p>연결 후 nautilus 명령어 실행</p>\n<p>exit - 로그아웃 명령어, SSH 접속을 끊음</p>\n<p>rsh(Remote SHell)은 네트워크에 그대로 내보내기 때문에 네트워크 감시자가 모을 수 있습니다.<br>\nrsh 보다 ssh 사용을 하면 암호화된 통신이 가능합니다.</p>\n<hr>\n<h3 id=\"2화-임시로-관리자-권한을-얻고-싶어sudo\">2화 임시로 관리자 권한을 얻고 싶어(sudo)</h3>\n<p>접근 권한은 파일 소유자가 아니면 바꿀 수 없지만, 처리할 수 있는 사용자가 있습니다. -> root</p>\n<p><code>sudo</code> - 관리자 권한을 행사할 수 있음</p>\n<pre><code class=\"language-bash\">sudo {실제 사용하고 싶은 명령어} {명령어 인자}\n</code></pre>\n<p>GUI이라면 gksudo -sync 명령어 사용</p>\n<p><strong>우분투에서 root로 로그인하기</strong><br>\nsudo -i 또는 sudo su로 가능 (명령어 입력 후 비밀번호를 입력해야 한다.)</p>\n<hr>\n<h3 id=\"3화-다양한-문자열을-한-번에-검색하고-싶어grep\">3화 다양한 문자열을 한 번에 검색하고 싶어(grep)</h3>\n<p><code>grep</code> - 파일 내용 중에 찾는 문자열이 포함되었는지를 조사해준다.(global regular expression print)</p>\n<pre><code class=\"language-bash\">grep {옵션} \"검색하고 싶은 문자열\" {찾을 파일이 있는 폴더 경로(검색 시작점)}\n</code></pre>\n<p><strong>grep 옵션</strong><br>\n-r : 서브 폴더까지 검색하도록 지정</p>\n<p>정규 표현식(regular expression)</p>\n<table>\n<thead>\n<tr>\n<th>값</th>\n<th>의미</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>()</td>\n<td>그룹화</td>\n</tr>\n<tr>\n<td>|</td>\n<td>좌우 중 하나</td>\n</tr>\n<tr>\n<td>?</td>\n<td>직전 표현이 0회 또는 1회 등장</td>\n</tr>\n<tr>\n<td>*</td>\n<td>직전 표현이 0회 이상 연속해서 등장</td>\n</tr>\n<tr>\n<td>+</td>\n<td>직전 표현이 1회 이상 연속해서 등장</td>\n</tr>\n<tr>\n<td>.</td>\n<td>임의의 한 문자</td>\n</tr>\n<tr>\n<td>^</td>\n<td>줄 머리</td>\n</tr>\n<tr>\n<td>$</td>\n<td>줄 끝</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>파일 내용을 대문자 소문자 차이를 무시하고 검색</p>\n</blockquote>\n<pre><code class=\"language-bash\">grep -r -i \"sungjun hwang\" 디렉토리 경로\n</code></pre>\n<blockquote>\n<p>파일 내용을 대문자 소문자 차이를 무시하고 정규 표현식으로 검색</p>\n</blockquote>\n<pre><code class=\"language-bash\">grep -r -i -E \"((성준) *(황)|sungjun +hwang)\" 디렉토리 경로\n</code></pre>\n<hr>\n<h3 id=\"4화-터미널에서도-대화형으로-파일을-편집하고-싶어vim\">4화 터미널에서도 대화형으로 파일을 편집하고 싶어(vim)</h3>\n<p><code>vim</code> - 명령줄용 텍스트 에디터(vi의 강화판)</p>\n<blockquote>\n<p>vim 설치 명령어</p>\n</blockquote>\n<pre><code class=\"language-bash\">sudo apt-get install vim\n또는\nyum install vim\n</code></pre>\n<pre><code class=\"language-bash\">sudo vim {편집하고 싶은 파일 경로}\n</code></pre>\n<p>i - 끼워넣기, INSERT<br>\n끼워넣기 모드 조작 방법</p>\n<ul>\n<li>화살표로 키로 커서를 움직이기</li>\n<li>키 입력으로 문자를 입력하기</li>\n<li>백스페이스키나 Del 키로 글자 지우기 등</li>\n</ul>\n<p>ESC - 편집을 끝낸다.</p>\n<p><strong>모드의 종류</strong><br>\n노멀 모드 - ESC로 돌아온 경우<br>\n끼워넣기 모드 - i, 일반 에디터와 같은 조작 방법<br>\n치환 모드 - Shift + r, 치환 모드용 조작 방법<br>\n선택 모드 - v, 선택 모드용 조작 방법<br>\n검색 모드 - /, 검색 모드용 조작 방법<br>\n등등...</p>\n<p>:wq - 저장하고 종료(Write, Quit)</p>\n<p><strong>검색 모드</strong><br>\n/ 키를 눌러서 검색 모드로 들어가고 검색하고 싶은 문자열을 입력하고 Enter<br>\nN - 다음으로 검색된 곳으로 이동<br>\nShift + N - 이전에 검색된 곳으로 이동<br>\n정규 표현식도 사용 가능</p>\n<blockquote>\n<p>더 자세한 명령어는 아래 사이트 참조</p>\n</blockquote>\n<p><a href=\"https://vim.rtorr.com/lang/ko\">Vim 치트 시트</a></p>\n<hr>\n<h3 id=\"5화-vim에서도-복사--붙이기--되돌리기를-하고-싶어yank\">5화 vim에서도 복사 &#x26; 붙이기 &#x26; 되돌리기를 하고 싶어(yank)</h3>\n<p><code>yank</code> - vim에 있는 클립보드 같은 것(vim 안에서만 사용)</p>\n<blockquote>\n<p>사용방법</p>\n</blockquote>\n<ol>\n<li>노멀 모드에서 v 키 입력 -> 비주얼 모드로 전환</li>\n<li>범위를 정하고 y 키 입력</li>\n<li>붙이고 장소로 이동하고 Shift + p 입력</li>\n<li>여러번 반복하고 싶은 경우 -> 10번 반복하고 싶다면 10 입력 후 Shift + p</li>\n</ol>\n<blockquote>\n<p>콘솔 일시정지</p>\n</blockquote>\n<ul>\n<li>Ctrl + z는 일시 정지 - 맥은 Control + z<br>\nfg를 입력해서 돌아가기(ForeGround)</li>\n</ul>\n<blockquote>\n<p>vim에서 되돌리기(Undo)</p>\n</blockquote>\n<ul>\n<li>노멀 모드에서 u 키 입력<br>\n다른 모드에 있다면 esc 키로 노멀 모드로 돌아온 다음 u 키</li>\n</ul>\n<blockquote>\n<p>되돌리기의 되살리기(Redo)</p>\n</blockquote>\n<ul>\n<li>Ctrl + r</li>\n</ul>\n<blockquote>\n<p>Undo, Redo 모두 횟수를 지정해 실행 가능</p>\n</blockquote>\n<ul>\n<li>10u / 10 ctrl + r</li>\n<li>9999u 는 첫 상태로 되돌아가는 것</li>\n</ul>\n<hr>\n<h3 id=\"6화-갑작스러운-네트워크-끊김에서-복귀하고-싶어가상-터미널\">6화 갑작스러운 네트워크 끊김에서 복귀하고 싶어(가상 터미널)</h3>\n<p>GNOME 단말은 데스크톱 환경에서 콘솔 환경을 들여다보는 창<br>\n가상 단말은 콘솔 환경에서 GNOME 단말이 하는 것과 같은 걸 하는 애플리케이션</p>\n<blockquote>\n<p>tmux 설치</p>\n</blockquote>\n<pre><code class=\"language-bash\">sudo apt-get install tmux &#x3C;- ssh로 연결된 서버에 설치\n\ntmux &#x3C;- 입력해서 실행\n\ntmux attach &#x3C;- ssh로 다시 서버에 접속한 후 재연결\n</code></pre>\n<blockquote>\n<p>빠져나오기</p>\n</blockquote>\n<ul>\n<li>ctrl + b 입력 후 d(Detach) 키 입력</li>\n</ul>\n<blockquote>\n<p>ctrl + b 입력 후 동작 키</p>\n</blockquote>\n<ul>\n<li>d - Detach</li>\n<li>c - Create (새로운 탭 생성)</li>\n<li>p - Previous (이전 탭 이동)</li>\n<li>n - Next (다음 탭 이동)</li>\n</ul>\n<p>ctrl 키와 영숫자 키 조합은 다른 애플리케이션에서도 다양하게 사용되기 때문에 충돌이 나지 않기 위해 이렇게 씁니다.</p>\n<hr>\n<h3 id=\"7화-다른-화면도-보면서-작업하고-싶어화면-분할\">7화 다른 화면도 보면서 작업하고 싶어(화면 분할)</h3>\n<blockquote>\n<p>tmux를 실행하고 화면 분할하는 방법</p>\n</blockquote>\n<ul>\n<li>ctrl + b 입력 후 \" 키를 입력 -> 화면 중앙으로 나뉨</li>\n</ul>\n<blockquote>\n<p>분할된 화면의 포커스 전환</p>\n</blockquote>\n<ul>\n<li>ctrl + b 다음 가고싶은 방향 화살표 키 입력</li>\n</ul>\n<blockquote>\n<p>화살표나 마우스 휠로 스크롤 하는 법</p>\n</blockquote>\n<ol>\n<li>ctrl + b 다음 [ 키 입력</li>\n<li>내용 확인 끝났으면 q 키 또는 esc로 원래 상태로 돌아올 수 있다.</li>\n</ol>\n<blockquote>\n<p>세로 분할하는 방법</p>\n</blockquote>\n<ul>\n<li>ctrl + b 다음 % 키 입력</li>\n</ul>\n<p>화면을 종료하고 싶은게 있다면 포커스를 옮기고 exit</p>\n<blockquote>\n<p>분할된 화면의 크기 변경 방법</p>\n</blockquote>\n<ol>\n<li>ctrl + b 키를 눌러 tmux 자체를 조작하는 상태로 둔다.</li>\n<li>ctrl + 방향키로 분할 경계선을 움직인다.</li>\n</ol>\n<hr>\n<h3 id=\"8화-최근-실행한-명령어를-호출하고-싶어명령어-이력\">8화 최근 실행한 명령어를 호출하고 싶어(명령어 이력)</h3>\n<p>셸에서 방향키를 위아래로 움직이면 이력을 확인할 수 있다.<br>\nvim ~/.bash_history 에서 이력을 볼 수 있다.<br>\nhistory 명령어 사용해도 볼 수 있다.</p>\n<blockquote>\n<p>예전의 명령어를 찾고 싶을 때(후방 검색)</p>\n</blockquote>\n<p>ctrl + r을 누른다. 맥은 control</p>\n<blockquote>\n<p>역방향으로 검색하는 방법</p>\n</blockquote>\n<p>zsh는 기본적으로 ctrl + s 입력하면 전방 검색이 가능</p>\n<p>vim ~/.bashrc로 bash 설정 파일을 열고 shift + g로 파일 마지막으로 이동<br>\n새로운 줄을 추가한 다음 stty stop undef 입력하고 저장<br>\n적용을 위해 bash를 재시작</p>\n<p>ctrl + s 키 입력 -> 검색 모드로 전환<br>\n현재 위치 기준으로 앞의 이력을 검색</p>\n<hr>\n<h3 id=\"9화-오래전에-실행한-명령어를-호출하고-싶어명령어-이력-검색\">9화 오래전에 실행한 명령어를 호출하고 싶어(명령어 이력 검색)</h3>\n<p>오랫동안 쓰지 않은 명령어는 보통 남아 있지 않는다.</p>\n<blockquote>\n<p>이력 개수를 늘리는 방법</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 설정 파일을 연다.\nvim ~/.bashrc\n\n# shift + g로 파일 끝으로 이동하고\n# 삽입모드로 아래 코드 추가 후 :wq로 나오기 (로그아웃 로그인 필요)\nexport HISTSIZE 10000\nexport HISTFILESIZE=10000\n</code></pre>\n<blockquote>\n<p>GNOME 단말에 이력을 동기화시키는 방법</p>\n</blockquote>\n<pre><code class=\"language-bash\"># GNOME 단말로 여러 탭을 사용하면 각각 다른 이력을 가지게 된다.\n# 다른 화면에서 bash 명령어 이력을 검색할 수 없게 된다. 아래 설정으로 해결\n\n# 설정 파일을 연다.\nvim ~/.bashrc\n\nfunction share_history {\n    history -a\n    history -c\n    history -r\n}\nPROMPT_COMMAND='share_history'\nshopt -u histappend\n</code></pre>\n<blockquote>\n<p>SSH 넘어서 명령어를 하나만 실행하기</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 명령어 끝에 접속한 곳에서 실행하고 싶은 명령어를 적는다.\nssh mint@server /scripts/do_backup.sh\n</code></pre>\n<hr>\n<h3 id=\"10화-네트워크-건너서-파일을-복사하고-싶어scp\">10화 네트워크 건너서 파일을 복사하고 싶어(scp)</h3>\n<p><code>scp</code> - Secure CoPy의 약어, 네트워크를 통해서 파일을 복사하는 명령어.</p>\n<blockquote>\n<p>사용방법</p>\n</blockquote>\n<p>사용할 곳과 보낼 곳에 scp가 설치되어 있어야 한다.</p>\n<pre><code class=\"language-bash\"># scp 파일 로그인할 사용자@접속할 컴퓨터:복사할 위치\nscp .file.ext mint@192.168.1.10:/tmp/\n</code></pre>\n<p>로그인에 사용한 사용자 홈 = mint@192.168.1.10:~/<br>\n다른 사용자의 홈 = mint@192.168.1.10:~ohno/<br>\n상대 경로는 로그인한 홈 디렉터리가 기점이 됨 = mint@192.168.1.10:../../tmp/</p>\n<blockquote>\n<p>다른 PC에서 내 PC로 가져오기 (반대방향)</p>\n</blockquote>\n<p>scp 복사 원본 복사(다른 컴퓨터에 있는 파일) 대상(자신의 PC 경로)</p>\n<blockquote>\n<p>와이드카드나 디렉터리로 복사</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 파일명 끝이 .log인 파일을 모드 복사\nscp mint@host:/tmp/*.log /tmp/\n\n# -r(recursively) 옵션으로 디렉터리를 재귀적으로 복사.\n# 복사 원본 경고로 디렉터리 지정 (/tmp/results 끝에 /)\nscp -r mint@host:/tmp/results/ /tmp/\n</code></pre>\n<hr>\n<h3 id=\"11화-시스템-과부하를-파악하고-싶어top\">11화 시스템 과부하를 파악하고 싶어(top)</h3>\n<p><code>top</code> - 시스템 부하 상태를 조사하는 명령어</p>\n<pre><code class=\"language-bash\">Processes: 708 total, 2 running, 706 sleeping, 2998 threads\nLoad Avg: 1.29, 1.22, 1.33  CPU usage: 2.78% user, 2.90% sys, 94.30% idle\nSharedLibs: 474M resident, 89M data, 30M linkedit.\nMemRegions: 188421 total, 3982M resident, 290M private, 3083M shared.\nPhysMem: 15G used (2020M wired), 671M unused.\nVM: 263T vsize, 3210M framework vsize, 257988(0) swapins, 394738(0) swapouts.\nNetworks: packets: 11857651/13G in, 8349910/1555M out.\nDisks: 7477011/195G read, 6148251/104G written.\n\nPID    COMMAND      %CPU TIME     #TH   #WQ  #PORT MEM    PURG   CMPRS  PGRP\n29678  iTerm2       9.0  00:15.52 7     4    265   135M   7072K  32M    29678\n349    WindowServer 8.1  04:13:24 24    4    2190  1502M  11M    364M   349\n63721  top          6.3  00:02.43 1/1   0    28    12M    0B     0B     63721\n0      kernel_task  4.5  02:38:05 460/8 0    0     80M    0B     0B     0\n340    bluetoothd   1.4  09:49.64 4     2    433   7298K  0B     1808K  340\n63126  Google Chrom 1.3  00:17.31 21    1    173   74M+   0B     16M    21772\n</code></pre>\n<p>Load Avg</p>\n<ul>\n<li>load average, 부하 지표</li>\n<li>CPU가 처리하는 걸 기다리는 작업의 갯수.</li>\n<li>1분당 평균으로 몇개의 일이 쌓이는지를 나타내는 값.</li>\n</ul>\n<p>%CPU와 TIME</p>\n<ul>\n<li>%CPU는 어느 프로세스가 얼만큼 쓰고 있는지 알려준다.</li>\n<li>TIME은 실제로 CPU를 사용한 시간</li>\n</ul>\n<p>top 명령어 실행 중</p>\n<ul>\n<li>c를 누르면 COMMAND 상세 표시 전환(나는 mode[n] 이런게 뜨면서 안된다..ㅜ)\\</li>\n<li>q를 누르면 종료</li>\n</ul>\n<blockquote>\n<p>프로세스 종료 방법</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 비밀번호 입력 후 성공하면 아무러 메시지가 표시되지 않는다.\nsudo kill {종료하고 싶은 PID}\n\n# 여러 프로세스를 한 번에 종료하기.\n# 프로세스 ID들을 스페이스로 띄어서 나열\nsudo kill {종료하고 싶은 PID} {종료하고 싶은 PID} {종료하고 싶은 PID}\n</code></pre>\n<blockquote>\n<p>민트의 정리</p>\n</blockquote>\n<ul>\n<li>load average >= CPU 코어수가 되면 과부하 상태</li>\n<li>CPU 사용률과 CPU 시간 양쪽이 큰 프로세스는 과부하 원인의 가능성이 높음</li>\n<li>과부하 원인인 프로세스는 kill 명령어로 종료함</li>\n</ul>\n<hr>\n<h3 id=\"12화-시스템-메모리-부족을-파악하고-싶어top-표시-전환\">12화 시스템 메모리 부족을 파악하고 싶어(top 표시 전환)</h3>\n<p>Load Avg가 높은 이유는 CPU 사용률 또는 메모리 부족이 원인</p>\n<p>프로그램은 필요할 때만 프로세스를 실행해서 처리가 끝나면 종료하는 것과<br>\n컴퓨터를 사용하는 동안 계속 프로세스를 실행시켜야 하는 것이 있다.<br>\n이런 상주형 프로세스를 서비스라고 부른다.</p>\n<blockquote>\n<p>기동 스크립트 사용법</p>\n</blockquote>\n<pre><code class=\"language-bash\"># service 명령어 (Ubuntu, CentOS, RedHat 등)\nsudo service apache2 restart\n\n# init.d 명령어 (Debian 등)\nsudo /etc/init.d/apache2 restart\n</code></pre>\n<p>스왑 영역도 전부 사용하게 되면 SSH 접속도 불가능할 때도 있다. (OOM Killer가 동작)</p>\n<p>메모리 사용량 순서 - shift + m<br>\nCPU 시간 순서로 나열 - shift + t<br>\nCPU 사용량 순서로 돌아가려면 - shift + p</p>\n<hr>\n<h3 id=\"13화-로그-파일에서-필요한-줄만-뽑고-싶어파이프라인\">13화 로그 파일에서 필요한 줄만 뽑고 싶어(파이프라인)</h3>\n<p><code>grep</code> - 파일에서 내용을 찾는 명령어</p>\n<blockquote>\n<p>사용방법</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 재귀적으로 /var/log/apache2/ 안에서 orange를 포함하는 파일을 찾는다.\ngrep -r \"orange\" /var/log/apache2/\n\n# 대상파일에서 orange를 찾는다.\ngrep \"orange\" /var/log/apache2/access.log\n</code></pre>\n<p><code>less</code> - 텍스트 파일을 한 번에 한 화면씩 보여주는 터미널 페이저</p>\n<pre><code class=\"language-bash\"># grep과 파이프라인을 이용해 함께 사용된다.\ngrep \"orange\" /var/log/apache2/access.log | less\n</code></pre>\n<p><code>cat</code> - 지정한 파일 내용을 읽어서 그대로 출력하는 명령어</p>\n<p><code>zcat</code> - 압축 파일을 읽어서 내용을 풀어서 출력하는 명령어(gzip 형식 전용 .gz, .tgz)</p>\n<p><code>xzcat</code> - xz 형식용 (.xz 파일)</p>\n<p><code>unzip</code> - zip 형식용</p>\n<p><code>tail</code> - 파일 내용 끝부분만 출력하는 명령어(-f 옵션을 통해 실시간으로 출력)</p>\n<pre><code class=\"language-bash\"># 이런식으로 조합해 사용 가능\ntail -F access.log | grep \"/retro\" | grep -v \"/live\" | less\n</code></pre>\n<blockquote>\n<p>파일 내용을 다음 명령어에 출력하는 시작 그룹</p>\n</blockquote>\n<p>파일 내용을 읽어서 출력</p>\n<ul>\n<li>cat</li>\n<li>zcat</li>\n<li>xzcat</li>\n</ul>\n<p>파일에 추가된 부분을 출력</p>\n<ul>\n<li>tail</li>\n</ul>\n<blockquote>\n<p>중간에서 이전 명령어 출력을 가공하는 중간 그룹</p>\n</blockquote>\n<ul>\n<li>grep - 해당하는 줄만 출력</li>\n<li>sort - 재정렬</li>\n<li>cut - 내용을 잘라냄</li>\n<li>uniq - 중복된 걸 제거</li>\n<li>sed - 내용을 변경</li>\n<li>awk - 내용을 변경</li>\n</ul>\n<blockquote>\n<p>이전 명령어 출력을 가공하는 최종 그룹</p>\n</blockquote>\n<ul>\n<li>less - 스크롤할 수 있게 출력</li>\n<li>tee - 파일을 저장</li>\n<li>wc - 줄 수나 문자 수를 카운트</li>\n<li>head - 첫 부분만 추출</li>\n</ul>\n<blockquote>\n<p>오코의 정리</p>\n</blockquote>\n<ul>\n<li>파이프라인을 사용하면 명령어끼리 조합해서 사용 가능</li>\n<li>grep은 다른 명령어 출력을 가공하는 데도 사용 가능</li>\n<li>zcat을 사용하면 압축된 로그 파일에서 바로 파이프라인으로 연결 가능</li>\n</ul>\n<hr>\n<h3 id=\"14화-작업-절차를-자동화하고-싶어셸-스크립트\">14화 작업 절차를 자동화하고 싶어(셸 스크립트)</h3>\n<p>cd 명령어를 인수 없이 실행하면 홈 디렉터리로 이동함.</p>\n<pre><code class=\"language-bash\">  Documents cd\n  ~\n</code></pre>\n<blockquote>\n<p>스크립트 작성방법</p>\n</blockquote>\n<p>setup.sh 같은 sh 확장자 파일을 생성한다.<br>\nvim setup.sh을 실행해 편집한다.<br>\n첫번째 줄에 아래와 같이 입력한다.</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n</code></pre>\n<p>셔뱅(shebang)으로 스크립트를 실행하는 프로그램(인터프리터)을 지정, Hash-Bang이라고도 한다.<br>\n프로그램 전체 경로를 적으면 스크립트를 실행하는 프로그램을 셸이 자동으로 전환해준다.<br>\nbash 이외에도 /usr/bin/perl /usr/bin/ruby1.9.1 등이 있다.</p>\n<blockquote>\n<p>스크립트를 실행 권한</p>\n</blockquote>\n<p>스크립트가 만들어졌다면 실행 권한을 주어야 한다.<br>\n<code>chmod</code> - 권한을 설정하는 명령어</p>\n<pre><code class=\"language-bash\">chmod +x setup.sh\n</code></pre>\n<blockquote>\n<p>스크립트 실행</p>\n</blockquote>\n<p>파일명을 쳐서 명령어 실행이 가능한 건 파일이 /bin/이나 /usr/bin/ 같은 특별한 장소에 있을 때 가능하다.</p>\n<ul>\n<li>O - /home/mint/setup.sh</li>\n<li>O - ./setup.sh</li>\n<li>O - ~mint/setup.sh</li>\n<li>X - setup.sh</li>\n</ul>\n<blockquote>\n<p>에러가 발생한 곳에서 처리를 끝내도록 하는 법</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 이전 명령어가 정상 종료했는지 확인하기\n# 이상 종료했으면 스크립트 실행을 중단하기\nif [ $? != 0 ]; then exit; fi\n</code></pre>\n<blockquote>\n<p>민트의 정리</p>\n</blockquote>\n<ul>\n<li>bash용 셸 스크립트를 작성하려면 텍스트 파일 첫 줄에 #!bin/bash라고 적고 두 번째 줄 이후는 자동 실행하고 싶은 셸 명령어를 작성한다.</li>\n<li>셸 스크립트는 chmod +x 파일명으로 실행 권한을 설정한다.</li>\n<li>명령어가 이상이 생겨서 그 시점에서 스크립트 실행을 중단하고 싶을 땐 if [ $? != 0 ]; then exit; fi 라고 적는다.</li>\n</ul>\n<hr>\n<h3 id=\"15화-같은-문자열을-스크립트에서-재사용하고-싶어셸-변수\">15화 같은 문자열을 스크립트에서 재사용하고 싶어(셸 변수)</h3>\n<blockquote>\n<p>스크립트 일괄 치환</p>\n</blockquote>\n<p>vim에서 일괄 치환을 쓰려면 esc키로 노멀 모드로 돌아간 후 아래 명령어 입력 후 enter</p>\n<pre><code class=\"language-bash\"># %s 전체 치환 명령어\n# 명령어 각 부분을 구분하는 문자 / 이외에도 임의의 문자를 사용 가능\n%s/원문/수정문/\n</code></pre>\n<blockquote>\n<p>변수 지정</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 변수명 = 변수값, x를 ~이라고 함이라는 표현에 가깝다.\nlog=/var/log/apache2/access.log\n\n# 사용은 $log, ${log}\nless $log\n</code></pre>\n<blockquote>\n<p>명령어를 변수 지정</p>\n</blockquote>\n<pre><code class=\"language-bash\"># tar xfv 파일 경로 -> 파일 압축 풀기\n# tar cfv 파일 경로 -> 파일 압축\ntar_extract=\"tar xfv\"\ntar_compress=\"tar cfv\"\n\n# 문자열을 eval 명령어에 넘기면 명령어열로 실행 가능\neval \"$tar_extract file.tar.gz\"\neval \"$tar_compress directory\"\n</code></pre>\n<blockquote>\n<p>공통 부분을 변수로 지정하는 방법</p>\n</blockquote>\n<pre><code class=\"language-bash\">base=/var/log/apache2\nlatest=${base}/access.log\nprev=${base}/acesss.log.7.gz\n</code></pre>\n<blockquote>\n<p>오코의 정리</p>\n</blockquote>\n<ul>\n<li>터미널이나 셸 스크립트에서 변수명=문자열이라고 작성하면 오른쪽 문자열이 값이고 왼쪽에 있는 게 이름인 변수가 정의됨</li>\n<li>그 이후는 $변수명 또는 ${변수명}으로 그 값과 동일하게 사용 가능</li>\n<li>유지 보수하기 쉽도록 변수명은 변수에 저장될 내용을 잘 설명하는 이름을 사용하기</li>\n</ul>\n<hr>\n<h3 id=\"16화-작업-환경과-상태를-정해서-스크립트를-실행하고-싶어환경-변수\">16화 작업 환경과 상태를 정해서 스크립트를 실행하고 싶어(환경 변수)</h3>\n<p><code>환경 변수</code> - 자기가 정의하지 않아도 $변수명으로 값을 참조할 수 있는 특수한 변수.</p>\n<p>${HOME} or $HOME - 홈 디렉토리 경로(/home/user, /home/admin, /home/mint)</p>\n<pre><code class=\"language-bash\"># 지금 환경에서 어떤 환경 변수를 쓸 수 있는지 볼 수 있다.\nenv\n</code></pre>\n<blockquote>\n<p>사용하기 편한 환경 변수</p>\n</blockquote>\n<ul>\n<li>HOME - 현재 사용자의 홈 디렉터리 경로</li>\n<li>PWD - 현재 디렉터리(작업 디렉터리) 경로</li>\n<li>EDITOR - 정해진 텍스트 에디터(vim, Emacs, nano 등) 경로</li>\n<li>PAGER - 정해진 페이저(less, lv 등) 경로</li>\n<li>USER - 현재 사용자의 사용자명</li>\n<li>GROUP - 현재 사용자의 그룹명</li>\n<li>HOSTNAME - 머신의 호스트명</li>\n</ul>\n<blockquote>\n<p>명령어 치환</p>\n</blockquote>\n<p>명령어열 실행 결과의 문자열로 치환된다.</p>\n<pre><code class=\"language-bash\"># 2021년 3월 29일 월요일 22시 50분 43초 KST\ndate\n\n# 210329\ndate +%y%m%d\n\n# 2021-03-29\ndate +%Y-%m-%d\n\n# 2021y03m29d22h\ndate +%Yy%mm%dd%Hh\n</code></pre>\n<blockquote>\n<p>오코의 정리</p>\n</blockquote>\n<ul>\n<li>환경 변수를 사용하면 셸 스크립트 실행 시 값이 변하므로 환경에 맞는 처리가 가능해짐</li>\n<li>$(명령어열) 또는 `명령어열`이라고 적으면 명령어열 실행 결과를 문자열로 적은 것과 같아짐(명령어 치환)</li>\n<li>명령어 치환에서 파이프라인이나 변수 등도 사용 가능</li>\n</ul>\n<hr>\n<h3 id=\"17화-로그-파일에서-필요한-줄만-뽑고-싶어cut\">17화 로그 파일에서 필요한 줄만 뽑고 싶어(cut)</h3>\n<p>파이프라인을 써서 명령어끼리 조합하기</p>\n<p>STEP 1</p>\n<pre><code class=\"language-bash\"># calculator 파일 내용 보기\ncat calculator.py\n\n# 기본 계산기\ndef add(a, b):\n  return a+b\n\ndef subtract(a, b):\n  return a-b\n\ndef multifply(a, b):\n  return a*b\n</code></pre>\n<p>STEP 2</p>\n<pre><code class=\"language-bash\"># return을 포함하지 않은 줄만 출력\ncat calculator.py | grep -v \"return\"\n\n# 기본 계산기\ndef add(a, b):\n\ndef subtract(a, b):\n\ndef multifply(a, b):\n</code></pre>\n<p>STEP 3</p>\n<pre><code class=\"language-bash\"># 원하는 부분만 잘라내기, less를 연결해 결과를 눈으로 확인할 수 있음\ncat calculator.py | grep -v \"return\" | cut -d \" \" -f 1 | less\n#\ndef\n\ndef\n\ndef\n</code></pre>\n<hr>\n<h3 id=\"18화-같은-내용의-줄을-세어보고-싶어sort와-uniq\">18화 같은 내용의 줄을 세어보고 싶어(sort와 uniq)</h3>\n<blockquote>\n<p>페이지 순위를 만드는 방법</p>\n</blockquote>\n<ul>\n<li>적절하지 않은 줄은 제외하고 필요한 줄만 집계대상으로 삼음</li>\n<li>로그 각 줄에서 접속한 페이지 경로를 추출</li>\n<li>경로 등장 횟수를 카운트</li>\n<li>등장 횟수로 경로를 재정렬</li>\n<li>상위와 하위 항목을 추출</li>\n</ul>\n<p><code>sort</code> - 입력된 내용을 알파벳 순서로 재정렬하는 명령어</p>\n<pre><code class=\"language-bash\"># 알파벳순\ncat input.txt | sort\n</code></pre>\n<p><strong>sort 옵션</strong></p>\n<p>--reverse, -r : 내림차순 정렬 (sort는 기본 오름차순 정렬)</p>\n<p><code>uniq</code> - IT 용어에서는 '같은 것이 없음'이라는 의미 사용할 때가 많다.</p>\n<pre><code class=\"language-bash\"># 같은 내용의 중복은 제거됨\ncat input.txt | uniq\n</code></pre>\n<p><strong>uniq 옵션</strong></p>\n<p>--count, -c : 각각 내용이 몇 번 등장했는가 출력</p>\n<p><strong>함께 사용한다면 이렇게 사용</strong></p>\n<pre><code class=\"language-bash\"># 결과를 less에 넘겨서 간단히 확인 가능\ncat /var/log/apache2/access.log | grep -v \"/live\" | cut -d \" \" -f 7 | sort | uniq -c | less\n</code></pre>\n<pre><code class=\"language-bash\"># 결과를 less에 넘겨서 간단히 확인 가능\ncat /var/log/apache2/access.log | grep -v \"/live\" | cut -d \" \" -f 7 | sort | uniq -c | less\n</code></pre>\n<blockquote>\n<p>요코의 정리</p>\n</blockquote>\n<pre><code class=\"language-bash\">#!/bin/bash\n\n# 집계 대상 로그 위치를 변경하기 쉽도록 변수로 정의\nlog=/var/log/apache2/access.log\n# 출력할 건수를 변경하기 쉽도록 변수로 정의\ncount=10\n\n# 결과 이전에 echo로 설명 텍스트를 출력\necho \"접속수가 많은 ${count}개 페이지:\"\n# 상위 10건 출력\ncat $log | grep -v \"/live\" | cut -d \" \" -f 7 | sort | uniq -c | sort -r | head -n $count\n\necho \"접속수가 적은 ${count}개 페이지:\"\n# 상위 10건 출력\ncat $log | grep -v \"/live\" | cut -d \" \" -f 7 | sort | uniq -c | sort -r | tail -n $count\n\n# cut -d \" \" -f 7 | sort | uniq -c : 페이지별 접속수 집계\n# sort -r : 접속수가 많은 순서로 정렬\n</code></pre>\n<blockquote>\n<p>첫 N줄, 마지막 N줄을 제외하기</p>\n</blockquote>\n<pre><code class=\"language-bash\"># 앞에서 5줄째\nhead -n 5\n# 앞에서 5줄째\nhead -n +5\n# 마지막 5줄을 제외한 나머지 모든 줄을 출력\nhead -n -5\n\n# 뒤에서 5줄째\ntail -n 5\n# 앞에 5줄을 제외한 나머지 모든 줄을 출력\ntail -n +5\n# 뒤에서 5줄째\ntail -n -5\n</code></pre>\n<p>MacOS에서 <code>head -n -5</code>를 하면 <code>head: illegal line count -- -5</code> 에러가 뜸</p>\n<hr>\n<h3 id=\"csv-파일을-열의-내용에-따라-정렬하고-싶어sort와-리다이렉트\">CSV 파일을 열의 내용에 따라 정렬하고 싶어(sort와 리다이렉트)</h3>\n<blockquote>\n<p>작업 순서</p>\n</blockquote>\n<ul>\n<li>불필요한 열을 삭제하기</li>\n<li>줄을 재고수 크기로 재정렬</li>\n<li>결과를 파일로 출력하기</li>\n</ul>\n<pre><code class=\"language-bash\"># 저는 liverpool.csv가 있습니다.\ncat liverpool.csv\n# 결과\nName,Position,Born,Number,Nationality\nRoberto Firmino,FW,1991,no. 9,Brazil\nSadio Mane,FW,1992,no. 10,Senegal\nMohamed Salah,FW,1992,no. 11,Egypt\nJoe Gomez,DF,1997,no. 12,England\nAlisson Becker,GK,1992,no. 13,Brazil\n\n# cut을 써서 간단히 열 단위로 정보를 추출 (시작 번호 1)\ncat liverpool.csv | cut -d \",\" -f 3\n\nBorn\n1991\n1992\n1992\n1997\n1992\n\n# 여러 숫자를 지정하거나 열 범위를 지정할 수 있다. (, 사이에 공백이 들어가면 cut: [-cf] list: values may not include zero 에러 발생)\ncat liverpool.csv | cut -d \",\" -f 1,3\nName,Born\nRoberto Firmino,1991\nSadio Mane,1992\nMohamed Salah,1992\nJoe Gomez,1997\nAlisson Becker,1992\n</code></pre>\n<p>cut 명령어</p>\n<ul>\n<li>사용법 cut -d \",\" -f 1,3</li>\n<li>-d는 --delimiter와 같다. (구분자를 지정하지 않으면 탭문자를 사용)</li>\n<li>-f는 --fields와 같다.</li>\n</ul>\n<p>sort 명령어</p>\n<ul>\n<li>사용법 sort -t \",\" -k 2 -n -b</li>\n<li>-t는 --field-separator와 같다.</li>\n<li>-k는 --key와 같다.</li>\n<li>숫자 정렬을 위해 --number 또는 -n 옵션을 지정한다.</li>\n<li>-b는 --ignore-leading-blanks로 오른쪽 줄맞춤을 위해서 넣은 스페이스를 무시하고 문자열을 정렬할 수 있게 해줌</li>\n</ul>\n<pre><code class=\"language-bash\">cat liverpool.csv | cut -d \",\" -f 1,3 | sort -t \",\" -k 2 -n -b\nName,Born\nRoberto Firmino,1991\nAlisson Becker,1992\nMohamed Salah,1992\nSadio Mane,1992\nJoe Gomez,1997\n</code></pre>\n<blockquote>\n<p>리다이렉트를 사용해 파일 만들기</p>\n</blockquote>\n<p>> 를 사용해 텍스트 파일로 만들 수 있다.<br>\n>> 두번 이어서 쓴다면 기존 파일에 추가된다. (덧붙여짐)</p>\n<pre><code class=\"language-bash\">cat liverpool.csv | cut -d \",\" -f 1,3 | sort -t \",\" -k 2 -n -b > test.csv\n</code></pre>\n<hr>\n<h3 id=\"20화-명령줄-지정으로-작업-내용을-바꾸고-싶어명령줄-인수\">20화 명령줄 지정으로 작업 내용을 바꾸고 싶어(명령줄 인수)</h3>\n<p>명령어명 뒤에 스페이스를 입력하고 대상을 적는 것 예) cat /var/log.apache2/access.log<br>\n명령어에 대해 추가 지시를 내리는 게 명령어 라인 인수\\</p>\n<p><strong>옵션은 인수의 한 종류</strong><br>\n생략 가능(지정하면 행동이 변하는)한 인수를 옵션 인수</p>\n<p>셸 스크립트 내부에서는 실행 시 지정한 인수 값을 $1, $2 같은 변수로 참조할 수 있다.<br>\n예) ./some_script.sh first second</p>\n<p>일반 명령어도 인수가 3개 이상이면 옵션으로 각각 의미가 있는 이름을 붙인다.</p>\n<pre><code class=\"language-bash\"># -b 옵션값을 base라는 변수로도 참조할 수 있다. 나머지도 동일.\nwhile getopts b:n:p:o: OPT\ndo\n  case $OPT in\n    b) base=\"$OPTARG\" ;;\n    n) next=\"$OPTARG\" ;;\n    p) previous=\"$OPTARG\" ;;\n    o) output=\"$OPTARG\" ;;\n  esac\ndone\n</code></pre>\n<hr>\n<h3 id=\"21화-조건에-따라-처리-흐름을-바꾸고-싶어조건-분기\">21화 조건에 따라 처리 흐름을 바꾸고 싶어(조건 분기)</h3>\n<p>셸 스크립트 안에 조건문을 넣어서 여러 상황을 처리할 수 있도록 한다.</p>\n<pre><code class=\"language-bash\"># $#은 스크립트에서 지정한 인수 개수를 의미하는 특수한 변수\nif [ $# = 2]\nthen # 줄바꿈 다음에 then을 써야 한다.\n  echo \"Hello!\" # 조건을 만족하면 실행하는 내용\nelse\n  echo \"Hi!\" # 조건을 만족하지 않으면 실행하는 내용\nfi\n\n# 줄바꿈 대신에 ;(세미콜론)을 사용하면 여러 줄을 한 줄로 합칠 수 있음\nif [ $# = 2 ]; then echo \"Hello!\"; else echo \"Hi!\"; fi\n</code></pre>\n<blockquote>\n<p>옵션이 있는지 확인하는 조건문</p>\n</blockquote>\n<pre><code class=\"language-bash\">while getopts f:r: OPT\ndo\n  case $OPT in\n    f) filename=\"$OPTARG\" ;;\n    r) reportname=\"$OPTARG\" ;;\n  esac\ndone\n\n# 부정 조건, 좌우 값이 다를 때를 의미\nif [ \"$reportname\" != \"\" ]\nthen\n  echo \"reportname O\"\nelse\n  echo \"reportname X\"\nfi\n</code></pre>\n<blockquote>\n<p>요코의 정리</p>\n</blockquote>\n<p>단순 조건 분기</p>\n<pre><code class=\"language-bash\">if [ $a = \"문자열\" ]\nthen\n  $a 내용이 \"문자열\"과 같다면 실행하는 처리\nfi\n</code></pre>\n<p>부정 조건으로 조건 분기</p>\n<pre><code class=\"language-bash\">if [ $a != \"문자열\" ]\nthen\n  $a 내용이 \"문자열\"과 다르면 실행하는 처리\nfi\n</code></pre>\n<p>조건에 해당하지 않을 때 처리</p>\n<pre><code class=\"language-bash\">if [ 조건 ]\nthen\n  조건을 만족하면 실행하는 처리\nelse\n  조건을 만족하지 않으면 실행하는 처리\nfi\n</code></pre>\n<p>시점을 넓혀서 생각하면 새로운 스크립트를 작성하기 전에 '이건 기존에 하던 작업의 일환으로 처리하는 게 자연스럽겠네'라는 게 보이기 시작한다.</p>\n<blockquote>\n<p>if나 [에 스페이스가 필요한 이유</p>\n</blockquote>\n<p>[도 명령어다.<br>\n실제 파일은 /usr/bin/[에 있다. (mac에서는 찾을 수 가 없음 ㅜㅜ)<br>\n[ - 명령어<br>\n$#, =, ] - 세 개가 다 인수</p>\n<hr>\n<h3 id=\"22화-명령어-이상-종료에-대응하고-싶어종료-상태\">22화 명령어 이상 종료에 대응하고 싶어(종료 상태)</h3>\n<p><code>에러 핸들링</code> - 어떤 문제가 발생했을 때 그것에 맞게 적절하게 처리하는 것<br>\n<code>$?</code> - 바로 전에 실행한 명령어 종료 상태, 0은 성공, 이상 종료는 값이 0이 아니다.</p>\n<pre><code class=\"language-bash\"># 줄바꿈 대신에 ;(세미콜론)을 사용하면 여러 줄을 한 줄로 합칠 수 있음\n# 이전 명령어 종료 상태가 0이 아니라면 스크립트 실행을 중단, 종료한다.\n# exit만 적으면 exit 0과 같다.\nif [ $? != 0 ]; then exit; fi\n\nif [ $1 = \"\" ]\nthen\n  echo \"처리할 파일을 지정해야 함\"\n  # 0 이외라면 무엇을 지정해도 됨(특별히 에러 종류를 구별할 필요가 없으면 1을 지정하는 게 보통)\n  exit 1\nfi\n</code></pre>\n<blockquote>\n<p>요코의 정리</p>\n</blockquote>\n<ul>\n<li>$?으로 직전에 실행한 명령어 종료 상태를 참조 가능</li>\n<li>$? 값은 명령어가 정상 종료하면 0, 이상 종료하면 0 이외의 값이 됨</li>\n<li>exit에 인수로 숫자를 지정하면 셸 스크립트의 종료 상태가 됨</li>\n<li>if로 종료 상태를 참조하면 명령어가 정상 종료했는지에 따라 조건 분기가 가능</li>\n</ul>\n<blockquote>\n<p>종료 상태 범위</p>\n</blockquote>\n<p>0은 정상 종료<br>\n0 ~ 255까지 범위가 있다.</p>\n<hr>\n<h3 id=\"23화-같은-처리를-반복해서-실행하고-싶어for\">23화 같은 처리를 반복해서 실행하고 싶어(for)</h3>\n<p>for 반복문 - 같은 처리를 조금씩 인수(처리 대상 파일명 등)를 바꿔가면서 반복 실행하는 구문</p>\n<pre><code class=\"language-bash\"># 네개의 값을 하나의 변수명으로 순서대로 참조한다는 의미\nfor filename in redmine.log kintail.log download.log notice.log\ndo\n  ./create-report.sh $filename\ndone\n</code></pre>\n<p>줄바꿈으로 표시하는 법</p>\n<pre><code class=\"language-bash\"># for ~ in 열은 줄바꿈을 넣으면 안된다.\n# 백슬래쉬(이스케이프)를 넣으면 가능하다. 한글 폰트에서는 원화 기호로 표시되기도 함\nfor filename in redmine.log \\\n                kintail.log \\\n                download.log \\\n                notice.log\n\n# 보기 쉽게 변수로 만드는 것도 좋은 방법.\nfilieList=redmine.log kintail.log download.log notice.log\nfor filename in $fileList\n\n# error.log를 제외한 /var/log/apache2/ 위치에 있는 확장자가 .log인 파일 목록\nfor filename in `cd /var/log/apache2; ls *.log | grep -v error.log`\n</code></pre>\n<blockquote>\n<p>요코의 정리</p>\n</blockquote>\n<ul>\n<li>for 반복문을 사용하면 값 리스트에 따라 같은 처리를 인수를 바꿔가며 반복 실행 가능</li>\n<li>반복문에서 사용하는 값 리스트로 변수나 명령어 치환 결과도 사용 가능</li>\n</ul>\n<blockquote>\n<p>for 반복물 한 줄로 쓰기</p>\n</blockquote>\n<pre><code class=\"language-bash\">for file in data log scripts; do echo $file; done\n</code></pre>\n<hr>\n<h3 id=\"공통-처리를-계속-재사용하고-싶어셸-함수\">공통 처리를 계속 재사용하고 싶어(셸 함수)</h3>\n<p>함수 - 프로그램에서 하나로 모아놓은 처리 단위에 이름을 붙여서 부품으로 사용하기 쉽게 만든 걸 뜻한다.</p>\n<pre><code class=\"language-bash\">#!/bin/bash\n\nhello() {\n  echo \"안녕하세요\"\n  echo \"$1입니다\"\n  echo \"잘 부탁합니다\"\n}\n\nhello 황성준\n</code></pre>\n<p>hello.sh로 만들고 <code>chmod +x hello.sh</code>으로 실행권한 부여 그 다음 ./hello.sh 실행하면 출력됨</p>\n<blockquote>\n<p>함수 종료 상태</p>\n</blockquote>\n<pre><code class=\"language-bash\">report() {\n  if [ $1 = \"\" ]\n  then\n    echo \"인수가 필요함\"\n    # 함수내에서 exit를 사용하면 함수뿐만 아니라 스크립트 자체 처리까지 도중에 중단.\n    return 1 # 함수 실행을 중단하고 종료 상태를 1로 지정함\n}\n\ntoday() {\n  # return date +%Y-%m-%d 으로 하면 반환되는 줄 알았지만 실행하면 아래와 같은 에러가 출력\n  # ./today.sh: line 4: return: date: numeric argument required\n\n  date +%Y-%m-%d # 함수 실행 결과는 명령어 실행 결과의 문자열이 됨\n}\n\nreport marketing.log mail-$(today).csv\n</code></pre>\n<blockquote>\n<p>요코의 정리</p>\n</blockquote>\n<ul>\n<li>어떤 처리를 하나도 묶어서 함수로 정의 가능함</li>\n<li>정의한 함수는 같은 스크립트 안에서 원하는 곳에서 몇번이고 호출할 수 있음</li>\n<li>함수도 인수를 사용 가능</li>\n<li>함수 실행을 중단하고 원래 처리로 돌아갈 때는 exit가 아니라 return 사용</li>\n</ul>\n<p>셸 스크립트는 기본적으로 실행하고 싶은 명령어를 실행 순서대로 작성하는 거지만<br>\n함수를 사용한다면 실행 순서를 신경 쓰지 않고 중요한 부분부터 스크립트를 작성한다.</p>\n<blockquote>\n<p>섈 스크립트의 인수와 함수의 인수</p>\n</blockquote>\n<p>함수 안에서 $1이라고 하면 셸 스크립트의 인수가 아니라 함수의 인수를 참조</p>\n</body>\n</html>\n"}},"__N_SSG":true}